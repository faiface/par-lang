<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Par Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Par programming language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Par Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/faiface/par-lang/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Par</strong> is affectionately named after the most bemusing connective of
<a href="https://en.wikipedia.org/wiki/Linear_logic">linear logic</a>: ⅋, pronounced <em>“par”</em>.
That’s because Par is based directly on (classical) linear logic, as an experiment to
see where this paradigm can take us.</p>
<p><a href="https://en.wikipedia.org/wiki/Jean-Yves_Girard">Jean-Yves Girard</a> — the author of linear logic,
and <a href="https://en.wikipedia.org/wiki/System_F">System F</a>, among other things — wrote on the page 3
of his <a href="https://www.sciencedirect.com/science/article/pii/0304397587900454">first paper on linear logic</a>:</p>
<blockquote>
<p>The new connectives of linear logic have obvious meanings in terms of
parallel computation, especially the multiplicatives.</p>
</blockquote>
<p>This was in 1987. In hindsight, it wasn’t that obvious.</p>
<p>Par is an attempt to take that idea seriously — to turn linear logic into a practical programming language.</p>
<h2 id="why-par"><a class="header" href="#why-par">Why <em>Par</em>?</a></h2>
<p>Based on linear logic, Par has a <strong>linear type system.</strong> That’s close to what you know from Rust:
linear values have a single owner and are moved instead of copied.
But unlike in Rust, linear values <strong>cannot be dropped.</strong> Instead, they have to be consumed according to their type.</p>
<p>This unlocks something special: channels that may only be consumed by sending.
Now the receiver has a new guarantee — it no longer has to consider the sender forgetting to communicate.</p>
<p>As a consequence, <strong>concurrent communication</strong> is as transparent and composable in Par as calling functions.
Together with Par’s imposition of a tree-like communication structure — <strong>ruling out deadlocks</strong> — a new
promising way of building concurrent applications arises.</p>
<p>But, Par isn’t just a concurrent language.</p>
<blockquote>
<p>In fact, real-world applications of Par’s concurrency are still
very limited, due to a lack of non-determinism, and poor I/O libraries. That’s because Par is
<strong>very new,</strong> but we’re working hard to bring both of these to a better state.</p>
<p>Yet, Par is still interesting for other reasons.</p>
</blockquote>
<p>Classical linear logic is a beast, and a powerful one
at that. Par absorbs all this power into its own expressivity. With <a href="./processes/duality.html"><strong>duality,</strong></a>
<strong>session types,</strong> and a rich set of concepts all mapping to logical connectives,
multiple paradigms emerge naturally:</p>
<ul>
<li><strong>Functional programming</strong> with side-effects via linear handles.</li>
<li>A <strong>unique object-oriented style,</strong> where interfaces are just types and implementations are just values.</li>
<li>An <strong>implicit concurrency,</strong> where execution is non-blocking by default.</li>
</ul>
<p>Multi-paradigm language often burden its users with multiple ways to solve the same problem.</p>
<p>But, somewhat surprisingly, we found that in Par, <strong>any single problem tends to have a single best solution.</strong>
That solution may be functional, object-oriented, a mix of those, or something else entirely.</p>
<p>Whichever one it is, it always puts a new puzzle into something there underneath: <strong>the <em>Par</em> way.</strong></p>
<h2 id="orthogonality-goes-wide-not-deep"><a class="header" href="#orthogonality-goes-wide-not-deep">Orthogonality goes <em>wide,</em> not deep</a></h2>
<p>Par doesn’t have dependent types, metaprogramming, higher-order kinds, or a macro system.
Instead of going deeper into complexity, <strong>Par goes wider.</strong></p>
<p>Its design focuses on small, composable ideas. For Par, it’s not that important to have a <em>small number</em>
of features. What’s important is that <em>each feature is small,</em> and covers something no other feature does.</p>
<p>Most of those ideas are taken directly from classical linear logic.
Every type corresponds to a logical connective. Even recursion! This has two consequences:</p>
<ul>
<li><strong>Everything fits together.</strong> Almost any combination of features has a meaningful use.</li>
<li><strong>Everything is a little different.</strong> For better or worse, Par is one of its kind.</li>
</ul>
<p>The former is great. The latter means Par might feel like learning programming all over again.
Will that be worthwhile? We’re going to have to find out.</p>
<h2 id="an-ambitious-stride-towards-totality"><a class="header" href="#an-ambitious-stride-towards-totality">An ambitious stride towards <em>totality</em></a></h2>
<p>As if session types and concurrency weren’t enough, Par also aims to be <strong>total.</strong></p>
<p>That means:</p>
<ul>
<li><strong>No exceptions or panics.</strong></li>
<li><strong>No deadlocks.</strong> Par imposes a structure where deadlocks are impossible to express.</li>
<li><strong>No accidental non-termination.</strong> By default, recursion and corecursion are checked to prevent infinite loops.</li>
</ul>
<blockquote>
<p>No infinite loops? How do I write a web server or an event loop? Don’t worry, that’s not infinite loops,
that’s what we call <em>corecursion.</em> It’s covered thoroughly by <a href="./types/iterative.html">iterative</a> types
with totality ensuring they always advance to their next step.</p>
</blockquote>
<p>At the moment, the system isn’t powerful enough to capture some more complex algorithms, so there’s an
escape hatch. But, the eventual goal is to get rid of it.</p>
<h2 id="lets-dive-in"><a class="header" href="#lets-dive-in">Let’s dive in!</a></h2>
<p>Par is a language in active development. It’s not production-ready — but it’s expressive, and ready to be
explored.</p>
<p>If you’re curious about what programming can look like when guided by logic — <strong>turn the page.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let’s install the <strong>Par</strong> programming language. Currently, we have:</p>
<ul>
<li>A <em>playground</em> to code and interactively explore your and built-in definitions via
an <em>automatic UI.</em></li>
<li>A <em><code>run</code></em> command to run definitions with the <a href="./types/unit.html">unit</a> type straight from
the console.</li>
<li>A <em><code>check</code></em> command to check Par programs for validity without actually running them.</li>
</ul>
<p>At the moment, there are no pre-built binaries, or releases, so we’ll have to build it from
souce.</p>
<h3 id="1-install-rust-and-cargo"><a class="header" href="#1-install-rust-and-cargo">1. Install Rust and Cargo</a></h3>
<p>Par is written in <a href="https://www.rust-lang.org">Rust</a>. To be able to build it from source,
we’ll need to install Rust and its build tool, called Cargo.</p>
<p>The easiest way to do that is via <a href="https://rustup.rs">rustup</a>. The website instructs:</p>
<blockquote>
<p>Run the following in your terminal, then follow the onscreen instructions.</p>
<pre><code>$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</blockquote>
<h3 id="2-clone-pars-repository"><a class="header" href="#2-clone-pars-repository">2. Clone Par’s repository</a></h3>
<p>The next step is to obtain Par’s source code. That is located on
<a href="https://github.com/faiface/par-lang">GitHub</a>. Clone it locally by running the following
in your terminal:</p>
<pre><code>$ git clone https://github.com/faiface/par-lang
</code></pre>
<h3 id="3-build-and-install-pars-cli-tool"><a class="header" href="#3-build-and-install-pars-cli-tool">3. Build and install Par’s CLI tool</a></h3>
<p>Navigate to the newly created directory:</p>
<pre><code>$ cd par-lang
</code></pre>
<p>Then install the executable using Cargo:</p>
<pre><code>$ cargo install --path .
</code></pre>
<p>This may take a while as Rust downloads and builds all the dependencies.</p>
<h3 id="4-try-it-out"><a class="header" href="#4-try-it-out">4. Try it out!</a></h3>
<p>A new <code>par-lang</code> command should now be available in your terminal. It may be necessary
to restart the terminal for it to appear.</p>
<p>If successful, start the Par’s playground:</p>
<pre><code>$ par-lang playground
</code></pre>
<p>And the playground should appear:</p>
<p><img src="./images/getting_started_1.png" alt="Playground window" /></p>
<p>If all is good, turn the page and <strong>let’s get into the language itself!</strong></p>
<p>In case of problems, head over to our <a href="https://discord.gg/8KsypefW99">Discord</a>, we’ll try and
help.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-program-structure"><a class="header" href="#basic-program-structure">Basic Program Structure</a></h1>
<p>For now, <em>Par</em> lacks a proper module system. Each program is contained in one file, with built-in
names imported automatically.</p>
<p>These built-in names are scoped in modules — for example, <code>Int.Add</code> is a function called <code>Add</code> in the
<code>Int</code> module — but there is no way to define custom modules. All we can do is define types and values,
and then run them, interactively!</p>
<p>Before we start defining our own types and values, the built-in definitions already give us something
to play with.</p>
<p>Let’s open the playground!</p>
<pre><code>$ par-lang playground
</code></pre>
<p>Press <strong>Compile</strong>, then hit the <strong>Run</strong> button:</p>
<p><img src="./images/basic_structure_1.png" alt="Run on an empty program" /></p>
<p>All the built-in names are there. Let’s run <code>Int.Add</code>:</p>
<p><img src="./images/basic_structure_2.png" alt="Run Int.Add" /></p>
<p>An <strong>automatic UI</strong> shows up, telling us to input two numbers. After confirming both inputs,
we get a result:</p>
<p><img src="./images/basic_structure_3.png" alt="Int.Add result" /></p>
<p>The playground features an <em>automatic</em> UI. Nobody made a specific interaface for this <code>Int.Add</code> function.
Instead, the UI that shows up is based purely on its type — here, a function from two integers to an
integer result.</p>
<p>Go ahead, and play with any built-in definition! Then, when you turn the page, we’re going to talk about
creating our own.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definitions--declarations"><a class="header" href="#definitions--declarations">Definitions &amp; Declarations</a></h1>
<p>At the top level, a <em>Par</em> file consists of <strong>definitions</strong>, <strong>declarations</strong>, and <strong>type definitions</strong>.</p>
<p>These define <strong>global names</strong> that can be used throughout the file, an unlimited number of times.</p>
<blockquote>
<p>Because of Par’s linear type system, local variables may be required to be used <em>exactly once.</em> That is
if they have a linear type. Global definitions can be used any number of times regardless of their
type.</p>
</blockquote>
<p>Par has a simple naming rule:</p>
<ul>
<li><strong>Global names start with an upper-case letter.</strong> That is global types, functions, and so on.</li>
<li><strong>Local names start with a lower-case letter, or <code>_</code>.</strong> That includes local variables, function
parameters, and type variables in generic functions.</li>
</ul>
<p>While global names can be used throughout the program, there is an <em>important restriction!</em></p>
<blockquote>
<p>❗ <strong>Cyclic usages are forbidden!</strong> Both in types, and in definitions.</p>
<p>That means that if a type <code>Alice</code> uses a type <code>Bob</code>, then <code>Bob</code> can’t use <code>Alice</code>. Same for functions,
and other definitions. In fact, <code>Alice</code> can’t use <code>Alice</code> either!</p>
</blockquote>
<p>This apparently mad restriction has important motivations, and innovative remedies.</p>
<p><strong>The motivation</strong> is Par’s ambitious stride towards <strong>totality</strong> — which means preventing
infinite loops.</p>
<p>Unrestricted recursion is a source of infinite loops, and while that can be partially
remedied by totality checkers, such as in <a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a>,
Par chooses a different approach. That is outlawing unrestricted recursion, and instead relying on more
<em>principled</em> ways to achieve cyclic behavior, including what’s usually achieved by mutual recursion.</p>
<p><strong>The remedies</strong> come in the form of these more principled ways. Fortunately, they don’t just replace the
familiar recursion by clunkier mechanisms, they bring their own perks.</p>
<p>Naive recursion on the term level (like in functions) is replaced by a powerful,
<strong>universal looping mechanism, called <code>begin</code>/<code>loop</code>.</strong> It’s a single tool usable for:</p>
<ul>
<li><em><a href="structure/../types/recursive.html">Recursive</a> reduction.</em> Analyzing lists, trees, or even files.</li>
<li><em><a href="structure/../types/iterative.html">Iterative</a> construction</em>. Those are objects that can be interacted
with repeatedly.</li>
<li><em>Imperative-looking loops</em> in <a href="structure/../process_syntax.html">process syntax</a>.</li>
</ul>
<p>Naive recursion in types is replaced by
<strong>anonymous <a href="structure/../types/recursive.html">recursive</a> and <a href="structure/../types/iterative.html">iterative</a> (corecursive) types.</strong></p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>Global values (including functions) are defined at the top level starting with the keyword <code>def</code>,
followed by an upper-case name, an <code>=</code> sign, and an expression computing the value.</p>
<pre><code class="language-par">def MyNumber = 7
</code></pre>
<p>In this case, Par is able to infer the type of <code>MyNumber</code> as <a href="structure/./primitive_types.html#nat"><code>Nat</code></a>
(a natural number), so no type annotation is needed. Often, a type annotation is needed, or wanted.
In those cases, we can add it using a colon after the name:</p>
<pre><code class="language-par">def MyName: String = "Michal"
</code></pre>
<h2 id="declarations"><a class="header" href="#declarations">Declarations</a></h2>
<p>Sometimes a type is longer and a definition becomes busy and hard to read with it.</p>
<p>For example, here’s a simple function adding up all the numbers in a list:</p>
<pre><code class="language-par">def SumList: [List&lt;Int&gt;] Int = [list] list.begin.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.loop),
}
</code></pre>
<p>The code uses many concepts that will be covered later, so only focus on the parts you know: <code>def</code>,
<code>:</code>, and <code>=</code>. <em>(You can run it in the playground, though!)</em></p>
<p>In such a case, the type annotation can be extracted into a separate <em>declaration</em>. A declaration
starts with the keyword <code>dec</code>, followed by the name we want to annotate, a colon, and a type.</p>
<pre><code class="language-par">dec SumList : [List&lt;Int&gt;] Int

def SumList = [list] list.begin.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.loop),
}
</code></pre>
<p>That’s much better!</p>
<p>Declarations may be placed anywhere in a file, so feel free to put them all on top, or keep them close
to their corresponding definitions.</p>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<p>Par has a <a href="structure/TODO">structural</a> type system. While many languages offer multiple forms of type definitions
— for example, Rust has <code>struct</code>, <code>enum</code>, and more — Par only has one: <strong>type aliases.</strong></p>
<blockquote>
<p>With <a href="structure/../types/recursive.html">recursive</a> and <a href="structure/../types/iterative.html">iterative</a> types being anonymous,
Par has no issue treating types as their shapes, instead of their names. In fact, type definitions are
completely redundant in Par. Every usage of a global type (with the exception of the
<a href="structure/./primitive_types.html">primitives</a>) can be replaced by its definition, until no definitions are
used.</p>
<p><em>Actually, all definitions are redundant in Par. However, programming without them would be quite tedious.</em></p>
</blockquote>
<p>To give a name to a type, use the <code>type</code> keyword at the top level, followed by an upper-case name,
an <code>=</code> sign, and a type to assign to it.</p>
<pre><code class="language-par">type MyString = String
</code></pre>
<p><code>MyString</code> is now equal to <code>String</code> and can be used wherever <code>String</code> can.</p>
<p>A more useful example:</p>
<pre><code class="language-par">type StringBuilder = iterative choice {
  .build =&gt; String,
  .add(String) =&gt; self,
}
</code></pre>
<blockquote>
<p>This particular type is a part of the built-in functionality, under the name <code>String.Builder</code>.</p>
</blockquote>
<p>That’s an <a href="structure/../types/iterative.html">iterative</a> <a href="structure/../types/choice.html">choice</a> type, something we will learn
later. It’s an object that can be interacted with repeatedly, choosing a branch (a method) every time.</p>
<p>While we could paste the entire definition every time we would use this <code>StringBuilder</code>, it’s quite
clear why we wouldn’t want to do that.</p>
<h3 id="generic-types"><a class="header" href="#generic-types">Generic types</a></h3>
<p>A type definition may include generic type parameters, turning it into a formula that can be instantiated
with any types substituted for the parameters.</p>
<p>The type parameters are specified in a comma-separated list inside angle brackets right after the
type name. The parameters are local names, so they must be lower-case.</p>
<p>For example, the built-in <code>List</code> type has one type parameter:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
<p>That’s a <a href="structure/../types/recursive.html">recursive</a> <a href="structure/../types/either.html">either</a> type, also something we will
learn later. In this case, it defines a finite, singly-linked list of items of type <code>a</code>.</p>
<p>To use a generic type, we append a comma-separated list of specific type arguments enclosed in
angle brackets after the type’s name.</p>
<pre><code class="language-par">type IntList = List&lt;Int&gt;
</code></pre>
<p>The resulting type is obtained by replacing each occurrence of each type variable by its corresponding
type argument. So, the above is equal to:</p>
<pre><code class="language-par">type IntListExpanded = recursive either {
  .end!,
  .item(Int) self,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Before taking a stroll in the diverse garden of Par’s types, let’s stop by the most basic ones:
the <em>primitives.</em></p>
<p>At the moment, Par has six primitive types:</p>
<ul>
<li><strong><code>Int</code></strong> — Integers, positive and negative whole numbers, arbitrary size.</li>
<li><strong><code>Nat</code></strong> — Natural numbers, starting from zero, arbitrary size. They are a subtype of <code>Int</code>.</li>
<li><strong><code>String</code></strong> — UTF-8 encoded sequence of Unicode characters.</li>
<li><strong><code>Char</code></strong> — Singular Unicode character. They are a subtype of <code>String</code>.</li>
<li><strong><code>Byte</code></strong> — Singular data unit that consists of eight bits. They are a subtype of <code>Bytes</code>.</li>
<li><strong><code>Bytes</code></strong> — Contiguous-in-memory sequence of bytes.</li>
</ul>
<blockquote>
<p>There’s a <strong>significant distinction</strong> between <em>primitives</em> and all other types in Par.</p>
<p>The thing is, Par has a fully structural type system. All custom type definitions are just
aliases — there is no way to create opaque types. <em>(But, encapsulation is perfectly possible.)</em></p>
<p>Primitives are different in that they are opaque. They are magical types, distinct from others,
that are operated on using magical built-in functions. This is necessary to achieve their
efficient representation.</p>
</blockquote>
<p>Primitives are manipulated using magical built-in functions.</p>
<p><strong>To find the list of all built-in functions:</strong></p>
<ol>
<li>Open the playground.
<pre><code>$ par-lang playground
</code></pre>
</li>
<li>Press <strong>Compile,</strong> and <strong>Run.</strong> Scroll the list that pops up.
<img src="structure/../images/strings_and_numbers_1.png" alt="List of built-in functions" /></li>
</ol>
<p>Alternatively, the <a href="structure/../builtin.html">Built-In Definitions</a> chapter contains all built-in definitions
available in the language.</p>
<p><strong>To figure out the type of a built-in function:</strong></p>
<ol>
<li>Assigning it to your own <code>def</code>, such as:
<pre><code class="language-par">def Examine = Int.ToString
</code></pre>
Par knows the type of <code>Int.String</code>, so it will infer it for <code>Examine</code> as well.</li>
<li>Press <strong>Compile.</strong></li>
<li>Move the cursor to the definition. The playground will display the type on the right,
in green.
<img src="structure/../images/strings_and_numbers_2.png" alt="Displayed type of a built-in function" /></li>
</ol>
<p>The type <code>[Int] String</code> is a <a href="structure/../types/function.html">function</a> from <code>Int</code> to <code>String</code>. We will cover
functions and other types in detail <a href="structure/../types.html">later</a>. Despite that, we’ll still play with
some built-in functions in this section. All you need to know is that
<strong>the square brackets enclose function arguments,</strong> and the result type follows. For example:</p>
<ul>
<li><code>[Int, Int] Int</code> is a function from two <code>Int</code>s to an <code>Int</code>.</li>
<li><code>[Int, Nat, Nat] Nat</code> is a function from one <code>Int</code> and two <code>Nat</code>s to a <code>Nat</code>.</li>
</ul>
<blockquote>
<p><strong>The current set of built-in functions is very minimal.</strong> They’re just enough to be able to
write more useful functions yourself, but they’re nowhere close to a standard library. For example,
there are no functions for analyzing strings, aside from <code>String.Reader</code>, which is flexible enough
to implement all you’d need. You just need to do it yourself.</p>
<p>Keep in mind that Par is early in development. It’s bringing an innovative paradigm, which we’re
still figuring out how to use best. Creating an expansive standard library would be premature
before we understand what’s actually going on here.</p>
</blockquote>
<p>Now, let’s take a look at the primitives!</p>
<h2 id="int"><a class="header" href="#int"><code>Int</code></a></h2>
<p>Integers are arbitrarily sized whole numbers, positive or negative.</p>
<p>Their literals consist of digits, optionally prefixed with <code>-</code> or <code>+</code>, and may include underscores
for readability.</p>
<pre><code class="language-par">def Num1: Int = 7
def Num2: Int = -123_456_789
</code></pre>
<p>The type annotations are not needed:</p>
<pre><code class="language-par">def Num3 = 42
def Num4 = -2202
</code></pre>
<p>Without annotations, <code>Num3</code> actually gets inferred as <code>Nat</code>. But, since <code>Nat</code> is a
subtype of <code>Int</code>, it can be treated as an <code>Int</code> too.</p>
<p>Built-in functions are used for arithmetic operations. For example:</p>
<pre><code class="language-par">def Num5 = Int.Add(3, 4)  // = 7
def Num6 = Int.Mul(3, 4)  // = 12
</code></pre>
<p>Go ahead and explore more of them in the playground!</p>
<h2 id="nat"><a class="header" href="#nat"><code>Nat</code></a></h2>
<p>Natural numbers are just integers excluding the negative ones. <code>Nat</code> is a subtype of <code>Int</code>, so
every variable of type <code>Nat</code> can be used as an <code>Int</code>, too.</p>
<pre><code class="language-par">def Num7 = 14  // inferred as `Nat`
def Num8 = 17  // inferred as `Nat`

// perfectly valid
def Num9 = Int.Add(Num7, Num8)
</code></pre>
<p>While <code>Num7</code> and <code>Num8</code> are inferred as <code>Nat</code>s, <code>Num9</code> will be an <code>Int</code> because that’s what
<code>Int.Add</code> returns. To get a <code>Nat</code> result, use <code>Nat.Add</code>, which only accepts <code>Nat</code>s:</p>
<pre><code class="language-par">def Num10 = Nat.Add(Num7, Num8)  // inferred as `Nat`
</code></pre>
<p><strong>Several built-in functions aid in converting <code>Int</code>s to <code>Nat</code>s.</strong> For example:</p>
<ul>
<li><strong><code>Nat.Max</code></strong> has type <code>[Nat, Int] Nat</code> — the second argument is allowed to be an <code>Int</code>.
Yet it’s guaranteed to return a <code>Nat</code>.</li>
<li><strong><code>Int.Abs</code></strong> has type <code>[Int] Nat</code> — an absolute value is always a <code>Nat</code>.</li>
</ul>
<pre><code class="language-par">def Num11: Nat = Nat.Max(0, -1000)  // = 0
def Num12: Nat = Int.Abs(-1000)     // = 1000
</code></pre>
<p>Unlike <code>Int</code>s, natural numbers can be looped on using <code>Nat.Repeat</code>, which is one of their main
uses. We’ll learn more about that in the section on <a href="structure/../types/recursive.html">recursive</a> types.</p>
<h2 id="string"><a class="header" href="#string"><code>String</code></a></h2>
<p>Strings are represented as UTF-8 encoded sequences of Unicode characters. Their literals are
enclosed in double quotes (<code>"</code>), and may contain escape sequences, such as <code>\n</code>, familiar from
other languages.</p>
<pre><code class="language-par">def Str1 = "Hello"  // inferred as `String`
def Str2 = "World"
</code></pre>
<p>To concatenate strings, use <code>String.Builder</code>. To fully understand how it works, we’ll need to
cover <a href="structure/../types/iterative.html">iterative</a> and <a href="structure/../types/choice.html">choice</a> types, but perhaps
you can get the idea:</p>
<pre><code class="language-par">def Str3 = String.Builder
  .add(Str1)
  .add(", ")
  .add(Str2)
  .build  // = "Hello, World"
</code></pre>
<p>Analyzing strings — such as finding, splitting, or parsing — is done using <code>String.Reader</code>.
To be able to use it, more knowledge of the language is needed first. But, feel
free to play with it in the playground, or check out the <code>StringManipulation.par</code> example in
the <code>examples/</code> folder.</p>
<p>Numbers can be converted to strings using <code>Int.ToString</code>:</p>
<pre><code class="language-par">def Str4 = Int.ToString(14)  // = "14"
def Str5 = Int.ToString(-7)  // = "-7"
</code></pre>
<p>Note, that <code>Nat</code> is a subtype of <code>Int</code>, so any natural number can also be converted to a string
this way, too. In fact, that’s exactly what happens with <code>Str4</code>.</p>
<h2 id="char"><a class="header" href="#char"><code>Char</code></a></h2>
<p>A <code>Char</code> is a single Unicode character. <code>Char</code> literals are enclosed in single quotes:</p>
<pre><code class="language-par">def Char1 = "a"  // inferred as `Char`
def Char2 = "\n"
</code></pre>
<p>Since <code>Char</code> is a subtype of <code>String</code>, every variable of type <code>Char</code> can be used as a <code>String</code>, too.</p>
<p>There’s a built-in function to check if a <code>Char</code> is a part of a character class:</p>
<pre><code class="language-par">def IsWhitespace = Char.Is(" ", .whitespace!)  // = .true!
</code></pre>
<p>There’s no built-in function turning a <code>String</code> to a list of <code>Char</code>s. Feel free to
copy-paste this one, if you ever need it:</p>
<pre><code class="language-par">dec Chars : [String] List&lt;Char&gt;
def Chars = [s] String.Reader(s).begin.char.case {
  .end _ =&gt; .end!,
  .char(c) rest =&gt; .item(c) rest.loop,
}
</code></pre>
<h2 id="byte"><a class="header" href="#byte"><code>Byte</code></a></h2>
<p>A byte consists of eight bits, whose numerical value can range from 0 and 255, inclusive. <code>Byte</code>
literals are written in decimal, enclosed in double angle brackets:</p>
<pre><code class="language-par">def Byte1 = &lt;&lt;65&gt;&gt;   // inferred as `Byte`
def Byte2 = &lt;&lt;321&gt;&gt;  // out-of-bounds values are automatically wrapped
</code></pre>
<p>Since <code>Byte</code> is a subtype of <code>Bytes</code>, every variable of type <code>Byte</code> can be used as a <code>Bytes</code>, too.</p>
<p>Just like <code>Char</code>s, there’s a built-in function to check if a <code>Byte</code> is a part of a byte class. For <code>Byte</code>s, that’s mainly byte ranges:</p>
<pre><code class="language-par">def IsMsbSet = Byte.Is(&lt;&lt;192&gt;&gt;, .range(&lt;&lt;128&gt;&gt;, &lt;&lt;255&gt;&gt;)!)  // .true!
</code></pre>
<h2 id="bytes"><a class="header" href="#bytes"><code>Bytes</code></a></h2>
<p><code>Bytes</code> are sequences of zero or more bytes, laid out contiguously in memory in order to take the least possible amount of space. Their literals are similar to those of <code>Byte</code>s, except
that multiple decimal values are allowed, and are delimited by spaces:</p>
<pre><code class="language-par">def Bytes1 = &lt;&lt;65 91&gt;&gt;  // inferred as `Bytes`
def Bytes2 = &lt;&lt; &gt;&gt;      // zero-byte sequence
// def Bytes3 = &lt;&lt;&gt;&gt;    // This triggers syntax error for now, but we intend to fix it
</code></pre>
<p>A <code>Bytes</code> can also be broken down to a list of <code>Byte</code>s:</p>
<pre><code class="language-par">dec Bytes : [Bytes] List&lt;Byte&gt;
def Bytes = [bs] Bytes.Reader(bs).begin.byte.case {
  .end _ =&gt; .end!,
  .byte(b) rest =&gt; .item(b) rest.loop,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-let-expression"><a class="header" href="#the-let-expression">The <code>let</code> Expression</a></h1>
<p>Just one last stop before setting on a tour through Par’s types and their expressions: the <code>let</code>
expression. It’s for assigning a variable and using it in another expression.</p>
<p>Start with the keyword <code>let</code>, then a lower-case name of the variable, an <code>=</code> sign, a value
to assign to the variable, and finally the keyword <code>in</code> followed by an expression that may use
the variable.</p>
<p>That’s a mouthful.</p>
<pre><code class="language-par">def Six = let three = 3 in Nat.Add(three, three)
</code></pre>
<p>The left side of the <code>=</code> sign can actually be more than a variable!</p>
<p>For one, it can have an annotation:</p>
<pre><code class="language-par">def Six = let three: Nat = 3 in Nat.Add(three, three)
</code></pre>
<p>And it can also be a pattern:</p>
<pre><code class="language-par">def Twelve = let (a, b)! = (3, 4)! in Nat.Mul(a, b)
</code></pre>
<p>The above is a combination of a <a href="structure/../types/pair.html">pair</a> and a <a href="structure/../types/unit.html">unit</a> pattern.
We’ll learn more about those soon.</p>
<blockquote>
<p>Type annotations always go after a variable name. So, this is invalid:</p>
<pre><code class="language-par">let (a, b)! : (Nat, Nat)! = (3, 4)! in ...  // Error!
</code></pre>
<p>The annotation does not follow a variable. But this is good:</p>
<pre><code class="language-par">let (a: Nat, b: Nat)! = (3, 4) in ...      // Okay.
</code></pre>
</blockquote>
<p><strong>Now, onto types and their expressions!</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-big-table"><a class="header" href="#the-big-table">The Big Table</a></h1>
<h2 id="expression-syntax"><a class="header" href="#expression-syntax">Expression syntax</a></h2>
<table>
<tr>
<td><strong>Type</strong></td>
<td><strong>Construction</strong></td>
<td><strong>Destruction</strong></td>
</tr>
<tr>
<td><pre><code class="language-par">type Unit = !
</code></pre></td>
<td><pre><code class="language-par">let value = !
</code></pre></td>
<td><pre><code class="language-par">let ! = value
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Either = either {
  .left String,
  .right Int,
}
</code></pre></td>
<td><pre><code class="language-par">let value: Either = .left "Hello!"
</code></pre></td>
<td><pre><code class="language-par">let result = value.case {
  .left str => String.Length(str),
  .right num => Int.Mul(num, 5),
}
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Pair = (String) Int
</code></pre></td>
<td><pre><code class="language-par">let value = ("Hello!") 42
</code></pre></td>
<td><pre><code class="language-par">let (str) num = value
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Function = [Int] String
</code></pre></td>
<td><pre><code class="language-par">let value = [num: Int] Int.ToString(num)
</code></pre></td>
<td><pre><code class="language-par">let str = value(42)
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Choice = choice {
  .left => String,
  .right => Int,
}
</code></pre></td>
<td><pre><code class="language-par">let value: Choice = case {
  .left => "Hello!",
  .right => 42,
}
</code></pre></td>
<td><pre><code class="language-par">let num = value.right
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Continuation = ?
</code></pre></td>
<td><em>No expression syntax</em></td>
<td><em>No expression syntax</em></td>
</tr>
</table>
<h2 id="process-syntax"><a class="header" href="#process-syntax">Process syntax</a></h2>
<table>
<tr>
<td><strong>Type</strong></td>
<td><strong>Construction</strong></td>
<td><strong>Destruction</strong></td>
</tr>
<tr>
<td><pre><code class="language-par">type Unit = !
</code></pre></td>
<td><pre><code class="language-par">let value = chan c {
  c!
}
</code></pre></td>
<td><pre><code class="language-par">value?
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Either = either {
  .left String,
  .right Int,
}
</code></pre></td>
<td><pre><code class="language-par">let value: Either = chan c {
  c.left
  c <> "Hello!"
}
</code></pre></td>
<td><pre><code class="language-par">value.case {
  .left => {
    let result = String.Length(value)
  }
  .right => {
    let result = Int.Mul(value, 5)
  }
}
// `result` is in scope here
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Pair = (String) Int
</code></pre></td>
<td><pre><code class="language-par">let value = chan c {
  c("Hello!")
  c <> 42
}
</code></pre></td>
<td><pre><code class="language-par">value[str]
let num = value
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Function = [Int] String
</code></pre></td>
<td><pre><code class="language-par">let value = chan c {
  c[num: Int]
  c <> Int.ToString(num)
}
</code></pre></td>
<td><pre><code class="language-par">value(42)
let result = value
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Choice = choice {
  .left => String,
  .right => Int,
}
</code></pre></td>
<td><pre><code class="language-par">let value = chan c {
  c.case {
    .left  => { c <> "Hello!" }
    .right => { c <> 42 }
  }
}
</code></pre></td>
<td><pre><code class="language-par">value.right
let num = value
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">type Continuation = ?
</code></pre></td>
<td><pre><code class="language-par">let outer: ! = chan break {
  let value: ? = chan c {
    c?     // construction
    break!
  }
  value!   // destruction
}
</code></pre></td>
<td><em>Shown on the left</em></td>
</tr>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-definitions"><a class="header" href="#built-in-definitions">Built-In Definitions</a></h1>
<pre><code class="language-par">/// Nat

dec Nat.Add   : [Nat, Nat] Nat
dec Nat.Mul   : [Nat, Nat] Nat
dec Nat.Div   : [Nat, Nat] Nat
dec Nat.Mod   : [Nat, Nat] Nat
dec Nat.Min   : [Nat, Nat] Nat
dec Nat.Max   : [Nat, Int] Nat
dec Nat.Clamp : [Int] [Nat, Nat] Nat

dec Nat.Equals  : [Nat, Nat] Bool
dec Nat.Compare : [Nat, Nat] Ordering

dec Nat.Repeat : [Nat] recursive either {
  .end!,
  .step self,
}

dec Nat.RepeatLazy : [Nat] recursive either {
  .end!,
  .step box choice {
    .next =&gt; self,
  }
}

dec Nat.Range : [Nat, Nat] List&lt;Nat&gt;

dec Nat.ToString : [Nat] String

dec Nat.FromString : [String] either {
  .ok Nat,
  .err!,
}


/// Int

dec Int.Add   : [Int, Int] Int
dec Int.Sub   : [Int, Int] Int
dec Int.Mul   : [Int, Int] Int
dec Int.Div   : [Int, Int] Int
dec Int.Mod   : [Int, Nat] Nat
dec Int.Min   : [Int, Int] Int
dec Int.Max   : [Int, Int] Int
dec Int.Abs   : [Int] Nat
dec Int.Clamp : [Int] [Int, Int] Int

dec Int.Equals  : [Int, Int] Bool
dec Int.Compare : [Int, Int] Ordering

dec Int.Range : [Int, Int] List&lt;Int&gt;

dec Int.ToString : [Int] String

dec Int.FromString : [String] either {
  .ok Int,
  .err!,
}


/// Bool

type Bool = either {
  .false!,
  .true!,
}


/// Result

type Result&lt;e, a&gt; = either {
  .ok a,
  .err e,
}

dec Result.Always : [type a] [Result&lt;either {}, a&gt;] a
def Result.Always = [type a] [result] result.case {
  .ok value =&gt; value,
  .err impossible =&gt; impossible.case {},
}

type Option&lt;a&gt; = Result&lt;!, a&gt;


/// List

type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}

type List.Builder&lt;a&gt; = iterative choice {
  .add(a) =&gt; self,
  .build =&gt; List&lt;a&gt;,
}

dec List.Builder : [type a] List.Builder&lt;a&gt;
def List.Builder = [type a]
  let append: [List&lt;a&gt;] List&lt;a&gt; = [xs] xs
  in begin case {
    .add(x) =&gt; let append = [xs: List&lt;a&gt;] append(.item(x) xs) in loop,
    .build =&gt; append(.end!),
  }


/// Ordering

type Ordering = either {
  .less!,
  .equal!,
  .greater!,
}


/// Char

type Char.Class = either {
  .any!,
  .char Char,
  .whitespace!,
  .ascii either {
    .any!,
    .alpha!,
    .alphanum!,
    .digit!,
  },
}

dec Char.Equals : [Char, Char] Bool
dec Char.Code   : [Char] Nat
dec Char.Is     : [Char, Char.Class] Bool


/// String

type String.Builder = iterative choice {
  .add(String) =&gt; self,
  .build =&gt; String,
}

type String.Parser&lt;e&gt; = recursive iterative/attempt choice {
  .close =&gt; Result&lt;e, !&gt;,
  .remainder =&gt; Result&lt;e, String&gt;,
  .char =&gt; either {
    .end Result&lt;e, !&gt;,
    .char(Char) self,
  },
  .match(String.Pattern, String.Pattern) =&gt; either {
    .end Result&lt;e, !&gt;,
    .fail self/attempt,
    .match(String, String) self,
  },
  .matchEnd(String.Pattern, String.Pattern) =&gt; either {
    .end Result&lt;e, !&gt;,
    .fail self/attempt,
    .match(String, String)!,
  },
}

type String.Pattern = recursive either {
  .empty!,
  .str String,
  .one Char.Class,
  .non Char.Class,
  .min Nat,
  .max Nat,
  .repeat self,
  .repeat1 self,
  .concat List&lt;self&gt;,
  .and List&lt;self&gt;,
  .or List&lt;self&gt;,
}

dec String.Quote     : [String] String
dec String.FromBytes : [Bytes] String

dec String.Equals    : [String, String] Bool
dec String.Compare   : [String, String] Ordering

dec String.Builder : String.Builder
dec String.Parser  : [String] String.Parser&lt;either {}&gt;

dec String.ParserFromReader : [type e] [Bytes.Reader&lt;e&gt;] String.Parser&lt;e&gt;


/// Byte

type Byte.Class = either {
  .any!,
  .byte Byte,
  .range(Byte, Byte)!,
}

dec Byte.Equals : [Byte, Byte] Bool
dec Byte.Code   : [Byte] Nat
dec Byte.Is     : [Byte, Byte.Class] Bool


/// Bytes

type Bytes.Builder = iterative choice {
  .add(Bytes) =&gt; self,
  .build =&gt; Bytes,
}

type Bytes.Reader&lt;e&gt; = recursive choice {
  .close =&gt; Result&lt;e, !&gt;,
  .read =&gt; Result&lt;e, either {
    .end!,
    .chunk(Bytes) self,
  }&gt;,
}

type Bytes.Writer&lt;e&gt; = iterative choice {
  .close =&gt; Result&lt;e, !&gt;,
  .flush =&gt; Result&lt;e, self&gt;,
  .write(Bytes) =&gt; Result&lt;e, self&gt;,
  .writeString(String) =&gt; Result&lt;e, self&gt;,
}

type Bytes.Parser&lt;e&gt; = recursive iterative/attempt choice {
  .close =&gt; Result&lt;e, !&gt;,
  .remainder =&gt; Result&lt;e, Bytes&gt;,
  .byte =&gt; either {
    .end Result&lt;e, !&gt;,
    .byte(Byte) self,
  },
  .match(Bytes.Pattern, Bytes.Pattern) =&gt; either {
    .end Result&lt;e, !&gt;,
    .fail self/attempt,
    .match(Bytes, Bytes) self,
  },
  .matchEnd(Bytes.Pattern, Bytes.Pattern) =&gt; either {
    .end Result&lt;e, !&gt;,
    .fail self/attempt,
    .match(Bytes, Bytes)!,
  },
}

type Bytes.Pattern = recursive either {
  .empty!,
  .bytes Bytes,
  .one Byte.Class,
  .non Byte.Class,
  .min Nat,
  .max Nat,
  .repeat self,
  .repeat1 self,
  .concat List&lt;self&gt;,
  .and List&lt;self&gt;,
  .or List&lt;self&gt;,
}

dec Bytes.Length  : [Bytes] Nat
dec Bytes.FromString : [String] Bytes

dec Bytes.Builder : Bytes.Builder
dec Bytes.Reader  : [Bytes] Bytes.Reader&lt;either {}&gt;
dec Bytes.Parser  : [Bytes] Bytes.Parser&lt;either {}&gt;

dec Bytes.EmptyReader      : Bytes.Reader&lt;either {}&gt;
dec Bytes.ReaderFromString : [String] Bytes.Reader&lt;either {}&gt;
dec Bytes.ParserFromReader : [type e] [Bytes.Reader&lt;e&gt;] Bytes.Parser&lt;e&gt;

dec Bytes.PipeReader : [type e] [[Bytes.Writer&lt;!&gt;] Result&lt;e, !&gt;] Bytes.Reader&lt;e&gt;


/// Console

type Console = iterative choice {
  .close =&gt; !,
  .print(String) =&gt; self,
  .prompt(String) =&gt; (Option&lt;String&gt;) self,
}

dec Console.Open : Console


/// Os

type Os.Error  = String
type Os.Reader = Bytes.Reader&lt;Os.Error&gt;
type Os.Writer = Bytes.Writer&lt;Os.Error&gt;

type Os.Path = iterative/append recursive/parent box choice {
  .stringName =&gt; String,
  .bytesName =&gt; Bytes,
  .stringAbsolute =&gt; String,
  .bytesAbsolute =&gt; Bytes,
  .stringParts =&gt; List&lt;String&gt;,
  .bytesParts =&gt; List&lt;Bytes&gt;,

  .parent =&gt; Option&lt;self/parent&gt;,
  .appendString(String) =&gt; self/append,
  .appendBytes(Bytes) =&gt; self/append,

  .openFile =&gt; Result&lt;Os.Error, Os.Reader&gt;,
  .createOrReplaceFile =&gt; Result&lt;Os.Error, Os.Writer&gt;,
  .createNewFile =&gt; Result&lt;Os.Error, Os.Writer&gt;,
  .appendToFile =&gt; Result&lt;Os.Error, Os.Writer&gt;,
  .createOrAppendToFile =&gt; Result&lt;Os.Error, Os.Writer&gt;,

  .listDir =&gt; Result&lt;Os.Error, List&lt;self/append&gt;&gt;,
  .traverseDir =&gt; Result&lt;Os.Error, recursive/tree either {
    .end!,
    .file(self/append) self/tree,
    .dir(self/append, self/tree) self/tree,
  }&gt;,
  .createDir =&gt; Result&lt;Os.Error, !&gt;,
}

dec Os.PathFromString : [String] Os.Path
dec Os.PathFromBytes  : [Bytes] Os.Path

dec Os.Stdin  : Os.Reader
dec Os.Stdout : Os.Writer


/// Url

type Url.Error = String

type Url = iterative box choice {
  .full =&gt; String,
  .protocol =&gt; String,
  .host =&gt; String,
  .path =&gt; String,
  .query =&gt; List&lt;(String) String&gt;,
  .appendPath(String) =&gt; self,
  .addQuery(String, String) =&gt; self,
}

dec Url.FromString : [String] Result&lt;Url.Error, Url&gt;


/// Http

type Http.Error  = String

type Http.Request =
  (String)
  (Url)
  (List&lt;(String) String&gt;)
  Bytes.Reader&lt;Http.Error&gt;

type Http.Response =
  (Nat)
  (List&lt;(String) String&gt;)
  Bytes.Reader&lt;Http.Error&gt;

dec Http.Fetch : [Http.Request] Result&lt;Http.Error, Http.Response&gt;

dec Http.Listen : [String] recursive either {
  .shutdown Result&lt;Http.Error, !&gt;,
  .incoming(Http.Request, [Http.Response] Result&lt;Http.Error, !&gt;) self,
}

/// Map

type Map&lt;k, v&gt; = iterative choice {
  .list =&gt; List&lt;(k) v&gt;,
  .entry(k) =&gt; (Option&lt;v&gt;) choice {
    .put(v) =&gt; self,
    .delete =&gt; self,
  },
}

dec Map.String : [type v] [List&lt;(String) box v&gt;] Map&lt;String, v&gt;
dec Map.Int    : [type v] [List&lt;(Int) box v&gt;]    Map&lt;Int, v&gt;
dec Map.Nat    : [type v] [List&lt;(Nat) box v&gt;]    Map&lt;Nat, v&gt;


/// BoxMap

type BoxMap&lt;k, v&gt; = iterative box choice {
  .list =&gt; List&lt;(k) box v&gt;,
  .get(k) =&gt; Option&lt;box v&gt;,
  .put(k, box v) =&gt; self,
  .delete(k) =&gt; self,
}

dec BoxMap.String : [type v] [List&lt;(String) box v&gt;] BoxMap&lt;String, v&gt;
dec BoxMap.Int    : [type v] [List&lt;(Int) box v&gt;]    BoxMap&lt;Int, v&gt;
dec BoxMap.Nat    : [type v] [List&lt;(Nat) box v&gt;]    BoxMap&lt;Nat, v&gt;


/// Cell

type Cell&lt;a&gt; = iterative choice {
  .end =&gt; ?,
  .split(dual self) =&gt; self,
  .take =&gt; (a) choice {
    .put(a) =&gt; self,
  }
}

dec Cell.Share : [type a] [a, dual Cell&lt;a&gt;] a


/// Debug

dec Debug.Log : [String] !
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types--their-expressions"><a class="header" href="#types--their-expressions">Types &amp; Their Expressions</a></h1>
<p>Types in Par serve two seemingly incompatible purposes at the same time:</p>
<ul>
<li>Objects of every-day programming, like functions and pairs.</li>
<li><a href="https://en.wikipedia.org/wiki/Session_type">Session-typed</a> communication channels.</li>
</ul>
<p>In the world of linear logic, these are the same thing. But to make this
connection harmonious and ergonomic, some unusual choices have to be made in the design of
the basic building blocks.</p>
<p><strong>Types in Par are sequential.</strong> The basic building blocks — pairs, functions, eithers (sums),
and choices (co-sums) — all read as <strong>first this, then that.</strong></p>
<p>Let’s take pairs. In many programming language, <code>(A, B)</code> is the type of a pair of <code>A</code> and <code>B</code>.
This approach is not sequential: both types assume equal position.</p>
<p>In Par, the pair type is instead <code>(A) B</code>. The second type being outside of the parentheses is
essential. It allows us to sequentially continue the type without the burden of nesting.</p>
<p>Compare <code>(A, (B, (C, D)))</code> against <code>(A) (B) (C) D</code>.</p>
<p>Of course, most languages that provide <code>(A, B)</code> pairs also support triples <code>(A, B, C)</code>, and
quadruples <code>(A, B, C, D)</code>, so let’s mix it up!</p>
<p>The usual syntax for function types is <code>A -&gt; B</code>. That is sequential, but in Par we have a syntax
that plays more nicely with the pairs: <code>[A] B</code>. Now compare</p>
<ul>
<li><code>(A, B -&gt; (C, D -&gt; E))</code></li>
</ul>
<p>versus</p>
<ul>
<li><code>(A) [B] (C) [D] E</code></li>
</ul>
<p>We can read it as: <em>first give <code>A</code>, then take <code>B</code>, then give <code>C</code>, then take <code>D</code>, and finally give <code>E</code>.</em></p>
<p>This is starting to look a lot like session types! An alternative reading of the type could be:
<em>first send <code>A</code>, then receive <code>B</code>, then send <code>C</code>, then receive <code>D</code>, and finally proceed as <code>E</code>.</em></p>
<p>And that, in a nutshell, is how Par unifies every-day types with session types.</p>
<p><strong>This chapter covers the every-day aspect of types in Par.</strong> For the session types aspect, check
out <a href="./processes.html">Processes</a>.</p>
<h2 id="linearity"><a class="header" href="#linearity">Linearity</a></h2>
<p>Par is based on <a href="https://en.wikipedia.org/wiki/Linear_logic">linear logic</a>, and with that comes a
<strong>linear type system.</strong> That means: <strong>some values must be used exactly once.</strong></p>
<p>These are called <strong>linear values.</strong> You can’t copy them, and you can’t throw them away.
They must be consumed, <strong>exactly once</strong> — in a way their type allows.</p>
<p>This might sound limiting, but it opens the door to something powerful.</p>
<p>When a value must be used — and can only be used once — it becomes possible to <strong>model communication.</strong>
Think about a channel that expects you to send a message. If you don’t send one — or send
two — things fall apart.</p>
<p>With linearity, Par gives you channels where that simply can’t happen.</p>
<p>That’s the foundation of <a href="https://en.wikipedia.org/wiki/Session_type">session types</a>,
and Par supports them at its core.</p>
<p>But not every type needs that kind of strictness. Some values should be copyable, droppable,
and passed around freely.</p>
<p>So Par distinguishes between:</p>
<ul>
<li><strong>Linear types,</strong> which must be used exactly once.</li>
<li><strong>Non-linear types,</strong> which can be used any number of times — including zero.</li>
</ul>
<p>Let’s look at what falls into each category.</p>
<h3 id="which-types-are-non-linear"><a class="header" href="#which-types-are-non-linear">Which types are non-linear?</a></h3>
<p>These are:</p>
<ul>
<li>All <a href="./structure/primitive_types.html"><strong>primitives</strong></a>: <code>Int</code>, <code>Nat</code>, <code>String</code>, <code>Char</code></li>
<li><a href="./types/unit.html"><strong>Unit</strong></a></li>
<li><a href="./types/either.html"><strong>Either</strong></a></li>
<li><a href="./types/pair.html"><strong>Pair</strong></a></li>
<li><a href="./types/recursive.html"><strong>Recursive</strong></a></li>
<li><a href="./types/box.html"><strong>Box</strong></a></li>
<li><a href="./types/exists.html"><strong>Exists</strong></a>, only if the body is non-linear — which is rare, since the
type variable it introduces is itself linear</li>
<li>Any type <strong>composed entirely</strong> of non-linear parts</li>
</ul>
<h3 id="which-types-are-linear"><a class="header" href="#which-types-are-linear">Which types are linear?</a></h3>
<p>All the rest:</p>
<ul>
<li><a href="./types/function.html"><strong>Function</strong></a></li>
<li><a href="./types/choice.html"><strong>Choice</strong></a></li>
<li><a href="./types/iterative.html"><strong>Iterative</strong></a></li>
<li><a href="./types/exists.html"><strong>Exists</strong></a>, <strong>in most cases,</strong> because they introduce a linear type variable</li>
<li><a href="./types/forall.html"><strong>Forall</strong></a></li>
<li><a href="./types/continuation.html"><strong>Continuation</strong></a></li>
<li>Any type that <strong>contains</strong> a linear component, even deeply</li>
</ul>
<p>If a type has a linear piece <strong>anywhere inside it,</strong> it becomes linear — unless that part is
wrapped in a <a href="./types/box.html">box</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit"><a class="header" href="#unit">Unit</a></h1>
<p>The unit type — spelled <code>!</code> — has a single value, also <code>!</code>.</p>
<pre><code class="language-par">def Unit: ! = !
</code></pre>
<p>Unit is frequently used as an end-marker for other types. All composite types — such as <a href="types/./pair.html">pairs</a>,
<a href="types/./either.html">eithers</a>, and <a href="types/./choice.html">choices</a> — have an obligatory <em>“and then”</em> part. The unit type
does the job for the case of <em>“and then nothing”</em>.</p>
<p>For example, the predefined <code>List&lt;a&gt;</code> type has this definition:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
<p>Each variant in an <a href="types/./either.html"><code>either</code></a> type has an obligatory payload. For the node marking the
end of the list, the payload is empty, and so it’s <code>!</code>.</p>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<p>The expression <code>!</code> has type <code>!</code> and is the only possible value for this type.</p>
<pre><code class="language-par">def Unit = !  // infers `Unit` to be of type `!`
</code></pre>
<h2 id="destruction"><a class="header" href="#destruction">Destruction</a></h2>
<p>Being a <a href="types/../types_and_expressions.html#linearity">non-linear</a> type, variables of type <code>!</code> can be left unused.</p>
<p>If <code>!</code> is a part of a larger type, it may be needed to assign it as a part of a pattern. For this
purpose, the pattern <code>!</code> will destruct a <code>!</code> value without assigning it to a variable.</p>
<pre><code class="language-par">def TestUnitDestruction = do {
  let unit = !
  let ! = unit
} in !
</code></pre>
<p>This is useful when matching an end of a list:</p>
<pre><code class="language-par">dec GetFirstOrZero : [List&lt;Int&gt;] Int
def GetFirstOrZero = [list] list.case {
  .end!      =&gt; 0,  // `!` is a pattern here
  .item(x) _ =&gt; x,
}
</code></pre>
<p>Or when destructing a <code>!</code>-ended <a href="types/./pair.html">tuple</a>:</p>
<pre><code class="language-par">dec SumPair : [(Int, Int)!] Int
def SumPair = [pair]
  let (x, y)! = pair  // `!` is a pattern here
  in Int.Add(x, y)

def Five =
  let pair = (2, 3)!
  in SumPair(pair)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="either"><a class="header" href="#either">Either</a></h1>
<p><em>Either types</em> are the well-known <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a>,
otherwise known as <em>tagged unions</em>.</p>
<p>They defined a finite number of variants, each with a different name and a payload. A value of
an either type is one of its variants.</p>
<pre><code class="language-par">type StringOrNumber = either {
  .string String,
  .number Int,
}

def Str: StringOrNumber = .string "Hello!"
def Num: StringOrNumber = .number 42,
</code></pre>
<p>An either type is spelled with the keyword <code>either</code>, followed by curly braces enclosing a
comma-separated list of variants.</p>
<p>Each variant has a lower-case name prefixed by a period and followed by a single, obligatory
payload type:</p>
<pre><code class="language-par">either {
  .variant1 Payload1,
  .variant2 Payload2,
  .variant3 Payload3,
}
</code></pre>
<p>Since each payload must be a single type, <a href="types/./unit.html">units</a>, <a href="types/./pair.html">pairs</a>, and other types
are used to define composite payloads. For example:</p>
<pre><code class="language-par">type MaybeBoth&lt;a, b&gt; = either {
  .neither!,
  .left a,
  .right b,
  .both(a, b)!,
}
</code></pre>
<blockquote>
<p>Either types are frequently used together with <a href="types/./recursive.html"><em>recursive</em></a> types to define finite
tree-like structures.</p>
<pre><code class="language-par">type BinaryTree&lt;a&gt; = recursive either {
  .empty!,
  .node(a, self, self)!,
}
</code></pre>
<p>The predefined <code>List&lt;a&gt;</code> type is a combination of <code>recursive</code> and <code>either</code>:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
</blockquote>
<h2 id="construction-1"><a class="header" href="#construction-1">Construction</a></h2>
<p>Values of <em>either</em> types are constructed starting with <code>.name</code> — the name of one of the variants in
the type — followed by an expression of the corresponding payload type.</p>
<p>Here are some examples of constructions for an either type that demonstrates many possible payloads:</p>
<pre><code class="language-par">type Varied = either {
  .unit!,                        // payload is `!`
  .string String,                // payload is `String`
  .number Int,                   // payload is `Int`
  .pair(Int) String,             // payload is `(Int) String`
  .symmetricPair(Int, String)!,  // payload is `(Int, String)!`
  .nested either {               // payload is another either type
    .left!,
    .right!,
  },
  .nested2(String) either {      // payload is a pair of `String` and another either
    .left!,
    .right!,
  }
}

def Example1: Varied = .unit!
def Example2: Varied = .string "Hello!"
def Example3: Varied = .number 42
def Example4: Varied = .pair(42) "Hello!"
def Example5: Varied = .symmetricPair(42, "Hello!")!
def Example6: Varied = .nested.left!
def Example7: Varied = .nested.right!
def Example8: Varied = .nested2("Hello!").left!
def Example9: Varied = .nested2("Hello!").right!
</code></pre>
<p><a href="types/./pair.html">Pairs</a> are frequently used in payloads of either types, both in their symmetric and sequential
styles. The sequential style makes chaining either types with attached payloads very natural, like
in the <code>.nested2</code> variant.</p>
<h2 id="destruction-1"><a class="header" href="#destruction-1">Destruction</a></h2>
<p>Values of <em>either types</em> can be deconstructed using <code>.case</code> expressions, similar to pattern-matching in
other languages.</p>
<p>A <code>.case</code> expression starts with the value to be destructed, followed by <code>.case</code>, and a list of
comma-separated branches enclosed in curly braces, one per each variant.</p>
<pre><code class="language-par">value.case {
  // branches
}
</code></pre>
<p>Each branch consists of the name of its variant, a <em>pattern</em> to assign the payload to, then a <code>=&gt;</code>
followed by an expression computing the result for that branch. All branches must evaluate to the
same type.</p>
<pre><code class="language-par">// branch
.name pattern =&gt; expression,
</code></pre>
<p>The patterns to assign the payloads are the same as can appear on the left side of
<code>let</code> assignments:</p>
<ul>
<li><code>variable</code> matches the whole value.</li>
<li><code>!</code> matches <a href="types/./unit.html">units</a>.</li>
<li><code>(pattern1, ...) patternN</code> matches <a href="types/./pair.html">pairs</a>.</li>
</ul>
<p>For a small example, we analyze the <code>Str</code> and <code>Num</code> values of the <code>StringOrNumber</code> type from above:</p>
<pre><code class="language-par">// evaluates to "Hello!"
def ResultForStr = Str.case {
  .string s =&gt; s,
  .number n =&gt; Int.ToString(n),
}

// evaluates to "42"
def ResultForNum = Num.case {
  .string s =&gt; s,
  .number n =&gt; Int.ToString(n),
}
</code></pre>
<p>For a comprehensive example, here’s a big <a href="types/./function.html">function</a> converting the above <code>Varied</code> type
to a <code>String</code>:</p>
<pre><code class="language-par">dec VariedToString : [Varied] String
def VariedToString = [varied] varied.case {
  .unit! =&gt; ".unit!",

  .string s =&gt; String.Builder.add(".string ").add(String.Quote(s)).build,

  .number n =&gt; String.Builder.add(".number ").add(Int.ToString(n)).build,

  .pair(n) s =&gt;
    String.Builder
      .add(".pair(")
      .add(Int.ToString(n))
      .add(") ")
      .add(String.Quote(s))
      .build,

  .symmetricPair(n, s)! =&gt;
    String.Builder
      .add(".symmetricPair(")
      .add(Int.ToString(n))
      .add(", ")
      .add(String.Quote(s))
      .add(")!")
      .build,

  .nested inside =&gt; String.Builder.add(".nested").add(inside.case {
    .left! =&gt; ".left!",
    .right! =&gt; ".right!",
  }).build,

  .nested2(s) inside =&gt;
    String.Builder
      .add(".nested2(")
      .add(String.Quote(s))
      .add(")")
      .add(inside.case {
        .left! =&gt; ".left!",
        .right! =&gt; ".right!",
      }).build,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pair"><a class="header" href="#pair">Pair</a></h1>
<p>A pair is two independent values packed into one. The only thing that differentiates pairs in Par,
compared to other languages, is their sequential syntax. While unusual, it makes pairs applicable
to a much wider set of use-cases.</p>
<p>A pair type consists of two types, the first enclosed in round parentheses.</p>
<pre><code class="language-par">type Pair = (String) Int
</code></pre>
<p>If the second type is another pair, we can use <em>syntax sugar</em> to write it more concisely:</p>
<pre><code class="language-par">type Triple1 = (String) (Int) String
type Triple2 = (String, Int) String
// these two are exactly the same type
</code></pre>
<p>For a <strong>symmetric pair</strong> syntax, it’s idiomatic to use the <a href="types/./unit.html">unit</a> type as the last element.</p>
<pre><code class="language-par">type SymmetricPair = (String, Int)!
</code></pre>
<p>Pairs in their sequential style are frequently used in combination with other types to insert values
into bigger structures. The predefined <code>List&lt;a&gt;</code> type uses a pair for its <code>.item</code> variant:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
<p>An infinite stream type may use a pair to produce an element together with the remainder of the stream:</p>
<pre><code class="language-par">type Stream&lt;a&gt; = iterative choice {
  .close =&gt; !,
  .next  =&gt; (a) self,
}
</code></pre>
<h2 id="construction-2"><a class="header" href="#construction-2">Construction</a></h2>
<p>Pair values look the same as their types, with values instead of types in place of elements.</p>
<pre><code class="language-par">def Example1: Pair    = ("Hello!") 42
def Example2: Triple1 = ("Alice") (42) "Bob"

// `Triple1` and `Triple2` really are the same type
def Example3: Triple1 = ("Alice", 42) "Bob"
def Example3: Triple2 = ("Alice", 42) "Bob"

// notice the `!` at the end
def Example4: SymmetricPair = ("Hello!", 42)!
</code></pre>
<p>When embedded in other types, sequential pairs blend in seamlessly:</p>
<pre><code class="language-par">def Names: List&lt;String&gt; = .item("Alice").item("Bob").item("Cyril").end!
//                             |             |           |_____________
//                             |             |_________________________
//                             |_______________________________________
</code></pre>
<h2 id="destruction-2"><a class="header" href="#destruction-2">Destruction</a></h2>
<p>Pairs are deconstructed in patterns on assignments. Those can appear in:</p>
<ul>
<li><a href="types/../structure/let_expressions.html"><code>let</code>-expressions</a></li>
<li><a href="types/./function.html">function</a> arguments</li>
<li><a href="types/./choice.html"><code>case</code></a>/<a href="types/./either.html"><code>.case</code></a> branches</li>
</ul>
<p>Aside from pairs and whole values, <a href="types/./unit.html">unit</a> types can be matched in patterns, too.</p>
<p>Here are some examples:</p>
<pre><code class="language-par">def Five: Int =
  let (x) y = (3) 2
  in Int.Add(x, y)

def FiveSymmetrically: Int =
  let (x, y)! = (3, 2)!
  in Int.Add(x, y)

dec AddSymmetricPair : [(Int, Int)!] Int
def AddSymmetricPair = [(x, y)!] Int.Add(x, y)
//                      \_____/&lt;---- pattern here

dec SumList : [List&lt;Int&gt;] Int
def SumList = [list] list.begin.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.loop),
//     \____/&lt;---- pattern here
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function"><a class="header" href="#function">Function</a></h1>
<p>A function transforms an argument into a result. The syntax for function types is designed to work well
with the rest of the type system, and resembles the syntax for <a href="types/./pair.html">pairs</a>, because the two are
<a href="types/../processes/duality.html">dual</a> to one another.</p>
<p>A function type consists of two types — the argument, and the result — the former enclosed in square
brackets.</p>
<pre><code class="language-par">type Function = [Int] String
</code></pre>
<p>If the result is another function, we can use <em>syntax sugar</em> to write it more concisely:</p>
<pre><code class="language-par">type BinaryFunction1 = [Int] [Int] Int
type BinaryFunction2 = [Int, Int] Int
// these two are exactly the same type
</code></pre>
<p>This is the preferred way to define functions of multiple arguments.</p>
<p><strong>Functions are <a href="types/TODO">linear</a>.</strong> While a globally defined function may be called any number of times,
a function stored in a local variable can (and must) only be called once:</p>
<pre><code class="language-par">dec Add : [Int, Int] Int
def Add = [x, y] Int.Add(x, y)

// a global function may be called many times
def Six = Add(1, Add(2, 3))  // Okay.

// but a function in a local variable can be only called once
def Illegal =
  let inc = Add(1)
  in Add(inc(2), inc(3))       // Error!
</code></pre>
<p><a href="types/TODO">Linearity</a> brings a lot of expressivity that wouldn’t be possible otherwise. After all, the main
purpose of <em>Par</em> is to explore where this new paradigm arising from linear types and duality can take us.</p>
<blockquote>
<p>Non-linear functions are achieved using <a href="types/./box.html">box types</a>.</p>
</blockquote>
<h2 id="construction-3"><a class="header" href="#construction-3">Construction</a></h2>
<p>Function values bind their argument inside square brackets, followed by an expression computing
the result.</p>
<pre><code class="language-par">dec Double : [Int] Int
def Double = [number] Int.Mul(2, number)
</code></pre>
<p>Multi-argument functions — or more precisely: functions returning other functions — can be expressed
using the same kind of a syntax sugar as available for their types:</p>
<pre><code class="language-par">dec Concat : [String, String] String
// the same as `[String] [String] String`

def Concat = [left, right]
  String.Builder.add(left).add(right).build
</code></pre>
<p>Patterns for deconstructing <a href="types/./pair.html">pairs</a> and <a href="types/./unit.html">units</a> can be used inside the
square brackets:</p>
<pre><code class="language-par">dec Swap : [(String, Int)!] (Int, String)!
def Swap = [(x, y)!] (y, x)!
</code></pre>
<p>Par uses <a href="https://arxiv.org/abs/1908.05839">bi-directional type-checking</a>. It’s a style of type-checking
that can infer a lot of types, but does not try to guess ahead. Functions are one of the types that it
cannot fully infer.</p>
<pre><code class="language-par">def Identity = [x] x  // Error! The type of `x` must be known.
</code></pre>
<p>If the type of a function isn’t known ahead of time, at least the type of its argument must be specified
explicitly:</p>
<pre><code class="language-par">def Identity = [x: String] x  // Okay.
</code></pre>
<p>For <strong>generic functions</strong>, read up on <a href="types/./forall.html"><em>forall</em> types</a>.</p>
<blockquote>
<p><strong><em>Par</em> has an unusual take on recursion,</strong> thanks to its ambitious stride towards <a href="types/TODO">totality</a>.
Naive recursion by self-reference is not allowed. In other words,
<strong>a function can’t directly call itself.</strong></p>
<pre><code class="language-par">def Infinity = Int.Add(1, Infinity)  // Error! Cyclic dependency.
</code></pre>
<p>Instead, <a href="types/./recursive.html">recursive</a> and <a href="types/./iterative.html">iterative</a> types are used for recursion
and <a href="https://en.wikipedia.org/wiki/Corecursion">corecursion</a>, respectively. Read up on them to learn
more.</p>
<p>Par’s powerful <code>begin</code>/<code>loop</code> syntax is a single, universal construct for cyclic computations.
It serves well in recursive functions, <a href="types/./iterative.html">iterative</a> objects, and imperative-looking loops
in <a href="types/../processes.html">process syntax</a>.</p>
<p>Forbidding functions from calling themselves may seem limiting at first, but <code>begin</code>/<code>loop</code> makes up
for it with its perky handling of local variables, and its ability to be used deep in expressions,
removing any need for recursive helper functions.</p>
</blockquote>
<h2 id="destruction-3"><a class="header" href="#destruction-3">Destruction</a></h2>
<p>Calling a function has the familiar syntax:</p>
<pre><code class="language-par">def Ten = Double(5)  // `Double` defined above
</code></pre>
<p>Functions with multiple arguments may be called by comma-separating the arguments inside
the parentheses:</p>
<pre><code class="language-par">def HelloWorld1 = Concat("Hello ", "World")  // `Concat` defined above
def HelloWorld2 = Concat("Hello ")("World")

def HelloWorld3 =
  let partial = Concat("Hello ")
  in partial("World")
</code></pre>
<p>All three versions do the same thing.</p>
<p>The word <em>destruction</em> is especially apt here, due to <a href="types/TODO">linearity</a> of functions. If a function
is stored in a local variable, calling it destroys the variable, as discussed above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forall"><a class="header" href="#forall">Forall</a></h1>
<p>What about <em>generic</em> functions? Or generic values?</p>
<p>We already know about <a href="types/../structure/definitions_and_declarations.html">generic types</a>. For example, here’s
a typical optional type, as present in many languages:</p>
<pre><code class="language-par">type Option&lt;a&gt; = either {
  .none!,
  .some a,
}
</code></pre>
<p>In Par, generic type definitions use the familiar angle bracket syntax. The parameters to those,
such as <code>a</code> for <code>Option&lt;a&gt;</code> may be replaced with anything, such as <code>Option&lt;Int&gt;</code>. The resulting type is,
however, always concrete.</p>
<p>Now consider these two definitions:</p>
<pre><code class="language-par">def None: Option&lt;String&gt; = .none!

dec Swap : [(String, Int)!] (Int, String)!
def Swap = [pair]
  let (first, second)! = pair
  in (second, first)!
</code></pre>
<p>Both are defined in terms of concrete types, but don’t use them: <code>.none!</code> is a valid value for
any <code>Option&lt;a&gt;</code>, and swapping a pair works regardless of its content.</p>
<p>To make these work with anything, we employ <em>forall</em> types!</p>
<p>In Par, <strong><em>forall</em> types:</strong></p>
<ul>
<li><strong>Don’t use angle brackets.</strong> Instead they are functions taking types.</li>
<li><strong>Are not inferred.</strong> Calling a generic function requires specifying the types.</li>
<li><strong>Are first-class!</strong> It’s possible to store and pass generic values around, without them losing
their genericity.</li>
</ul>
<p>A forall type <strong>consists of two parts:</strong></p>
<ul>
<li>A lower-case type variable enclosed in square brackets, and prefixed with the keyword <code>type</code>.</li>
<li>The result type, which uses this type variable.</li>
</ul>
<pre><code class="language-par">dec None : [type a] Option&lt;a&gt;

dec Swap : [type a] [type b] [(a, b)!] (b, a)!
</code></pre>
<p>After erasing the previous concrete definitions for <code>None</code>, these will be their generic types. As we can
see, these look just like functions, but taking types!</p>
<p>If the result of a forall type is another forall types — like with <code>Swap</code> — we can use syntax sugar to
put them both in one pair of square brackets:</p>
<pre><code class="language-par">dec Swap : [type a, b] [(a, b)!] (b, a)!
</code></pre>
<p>This looks better. The two ways are, however, completely equivalent.</p>
<p>Just like functions, foralls are <a href="types/TODO"><strong>linear</strong></a>. Variables containing them can’t be dropped, nor
copied, only destructed by calling.</p>
<h2 id="construction-4"><a class="header" href="#construction-4">Construction</a></h2>
<p>Values of forall types are constructed the same way as functions, except the argument is a type
variable and prefixed with the keyword <code>type</code>.</p>
<p>Completing the definitions above:</p>
<pre><code class="language-par">dec None : [type a] Option&lt;a&gt;
def None = [type a] .none!

dec Swap : [type a, b] [(a, b)!] (b, a)!
def Swap = [type a, b] [pair]
  let (first, second)! = pair
  in (second, first)!
</code></pre>
<blockquote>
<p>A common complaint at this point is:
<strong>Why do I have to write <code>[type a, b]</code> in both the declaration, and the definition?</strong> After all,
it doesn’t seem like they’re used in the definition. However, they are! What’s the type of <code>first</code>?
It’s <code>a</code>. And <code>second</code>? It’s <code>b</code>. If you called them <code>[type kek, dek]</code>, they would be <code>kek</code> and <code>dek</code>.
Par’s type checker never makes type names up.</p>
<p>Additionally, if you do end up needing to use those type variables — for example, to call another
generic function — they will be right at hand.</p>
</blockquote>
<h2 id="destruction-4"><a class="header" href="#destruction-4">Destruction</a></h2>
<p>Using a <em>forall</em> value looks the same as calling a function, except the argument is a concrete type,
prefixed with the keyword <code>type</code>.</p>
<pre><code class="language-par">def NoneInt = None(type Int)  // type inferred as `Option&lt;Int&gt;`

def Pair    = ("Hello!", 42)!
def Swapped = Swap(type String, Int)(Pair)
//          = (42, "Hello!")!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive"><a class="header" href="#recursive">Recursive</a></h1>
<p><em>Par</em> has, among others, these two ambitious design choices:</p>
<ul>
<li><strong>Totality,</strong> meaning preventing infinite loops by type-checking.</li>
<li><strong>A structural type system,</strong> where global type definitions are merely aliases.</li>
</ul>
<p>When it comes to self-referential types, totality necessitates distinguishing between:</p>
<ul>
<li><em>Recursive types</em>, those are finite.</li>
<li><em>Corecursive types</em>, potentially infinite. In Par, we call them <a href="types/./iterative.html"><em>iterative types</em></a>.</li>
</ul>
<p>The choice of a structural type system has led to avoiding defining self-referential types naively,
and instead adding a first-class syntax for anonymous self-referential types.</p>
<p>Par is very radical here. If you try the usual way of defining a singly-linked list, it fails:</p>
<pre><code class="language-par">type IllegalList = either {
  .end!,
  .item(String) IllegalList,  // Error! Cyclic dependency.
}
</code></pre>
<p>In general, <strong>cyclic dependencies between global definitions are disallowed.</strong> Instead, we have:</p>
<ul>
<li>Anonymous self-referential types: <code>recursive</code> and <a href="types/./iterative.html"><code>iterative</code></a>.</li>
<li>A single, universal recursion construct: <code>begin</code>/<code>loop</code>. It’s suitable for recursive destruction,
iterative construction, and imperative-style loops in <a href="types/../processes.html">process syntax</a>.</li>
</ul>
<p><strong>Let’s take a look at <code>recursive</code>!</strong></p>
<blockquote>
<p><strong>Totality <em>does not</em> mean you can’t have a web server, or a game.</strong> While these are often
implemented using infinite event loops, it doesn’t have to be done that way. Instead, we can employ
corecursion, which Par supports with its <a href="types/./iterative.html">iterative</a> types.</p>
<p>To make it clearer, consider this Python program:</p>
<pre><code class="language-python">def __main__():
    while True:
        req = next_request()
        if req is None:
            break
        handle_request(req)
</code></pre>
<p>That’s a simplified web server, handling requests one by one, using an infinite loop.</p>
<p>Could we switch it around and not have an infinite loop? Absolutely!</p>
<pre><code class="language-python">class WebServer:
    def close(self):
        pass

    def handle(req):
        handle_request(req)

def __main__():
    start_server(WebServer())
</code></pre>
<p>A small restructuring goes a long way here. <a href="types/./iterative.html">Iterative</a> types in Par enable
precisely this pattern, but with the ergonomics of the infinite loop version.</p>
</blockquote>
<p>A recursive type starts with the keyword <code>recursive</code> followed by a body that may contain any number
of occurrences of <code>self</code>: the self-reference.</p>
<pre><code class="language-par">type LegalList = recursive either {
  .end!,
  .item(String) self,  // Okay.
}
</code></pre>
<blockquote>
<p><strong>If there are nested <code>recursive</code> (or <a href="types/./iterative.html"><code>iterative</code></a>) types, it may be necessary to
distinguish between them.</strong> For that, we can attach <strong>labels</strong> to <code>recursive</code> and <code>self</code>. That’s
done with a slash: <code>recursive/label</code>, <code>self/label</code>. Any lower-case identifier can be used for the
label.</p>
</blockquote>
<p>The recursive type can be thought of as being equivalent to its <em>expansion</em>. That is, replacing each
<code>self</code> inside the body with the <code>recursive</code> type itself:</p>
<ol>
<li>The original definition:
<pre><code class="language-par">recursive either {
  .end!,
  .item(String) self
}
</code></pre>
</li>
<li>The first expansion:
<pre><code class="language-par">either {
  .end!,
  .item(String) recursive either {
    .end!,
    .item(String) self
  }
}
</code></pre>
</li>
<li>The second expansion:
<pre><code class="language-par">either {
  .end!,
  .item(String) either {
    .end!,
    .item(String) recursive either {
      .end!,
      .item(String) self
    }
  }
}
</code></pre>
</li>
<li>And so on…</li>
</ol>
<blockquote>
<p>The body of a <code>recursive</code> often starts with an <code>either</code>, but doesn’t have to. Here’s an example of that:
a non-empty list, which starts with a pair.</p>
<pre><code class="language-par">type NonEmptyList&lt;a&gt; = recursive (a) either {
  .end!,
  .item self,
}
</code></pre>
<p>Another example of a <code>recursive</code> type, which doesn’t start with an <code>either</code> would be a finite stream.</p>
<pre><code class="language-par">type FiniteStream&lt;a&gt; = recursive choice {
  .close =&gt; !,
  .next =&gt; either {
    .end!,
    .item(a) self,
  }
}
</code></pre>
<p>This one starts with a <a href="types/./choice.html">choice</a>, which enables polling the elements on demand, or
cancelling the rest of the stream. However, being recursive, a <code>FiniteStream&lt;a&gt;</code> is guaranteed
to reach the <code>.end!</code> eventually, if not cancelled.</p>
<p>There is nonetheless an important restriction: in order for <code>self</code> references to remain useful,
<strong>every <code>self</code> reference for a <code>recursive</code> must be guarded by an <code>either</code>.</strong> The <code>either</code> doesn’t
have to be right next to the <code>recursive</code>, but it <em>has</em> to be somewhere in-between <code>recursive</code> and
<code>self</code>:</p>
<pre><code class="language-par">type ValidList&lt;a&gt; = recursive (a) either {
  .end!,
  .item self,  // Okay. This `self` is guarded by an `either`.
}

type InvalidList&lt;a&gt; = recursive (a) self  // Error! Unguarded `self` reference
</code></pre>
<p><a href="types/./iterative.html">Iterative</a> types have a similar restriction: <strong>their <code>self</code> reference must be
guarded by a <a href="types/./choice.html"><code>choice</code></a>.</strong></p>
</blockquote>
<p>The key features of <em>recursive types</em> are that <strong>their values are finite,</strong> and that
<strong>we can perform recursion on them.</strong></p>
<h2 id="construction-5"><a class="header" href="#construction-5">Construction</a></h2>
<p>Recursive types don’t have any special construction syntax. Instead, we directly construct their
bodies, as if they were expanded.</p>
<pre><code class="language-par">type Tree = recursive either {
  .leaf Int,
  .node(self, self)!,
}

def SmallTree: Tree = .node(
  .node(
    .leaf 1,
    .leaf 2,
  )!,
  .node(
    .leaf 3,
    .leaf 4,
  )!,
)!
</code></pre>
<p>Already constructed recursive values can be used in the <code>self</code>-places of new ones:</p>
<pre><code class="language-par">def BiggerTree: Tree = .node(SmallTree, SmallTree)!
</code></pre>
<p><strong>Lists</strong> are a frequently used recursive type, and so are predefined as:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
<p>Constructing them goes like:</p>
<pre><code class="language-par">dec OneThroughFive  : List&lt;Int&gt;
dec ZeroThroughFive : List&lt;Int&gt;

def OneThroughFive  = .item(1).item(2).item(3).item(4).item(5).end!
def ZeroThroughFive = .item(0) OneThroughFive
</code></pre>
<p>Because lists are so ubiquitous, there is additionally a <strong>syntax sugar</strong> for constructing them more
concisely:</p>
<pre><code class="language-par">def OneThroughFive = *(1, 2, 3, 4, 5)
</code></pre>
<p>However, prepending onto an existing list has no syntax sugar, so <code>ZeroThroughFive</code> still has to be
done the same way.</p>
<h2 id="destruction-5"><a class="header" href="#destruction-5">Destruction</a></h2>
<p>If we don’t need to perform recursion, it’s possible to treat recursive types as their expansions
when destructing them, too. For example, here we treat a <code>List&lt;String&gt;</code> as its underlying <code>either</code>:</p>
<pre><code class="language-par">type Option&lt;a&gt; = either {
  .none!,
  .some a,
}

dec Head : [List&lt;String&gt;] Option&lt;String&gt;
def Head = [list] list.case {
  .end!      =&gt; .none!,
  .item(x) _ =&gt; .some x,
}
</code></pre>
<p><strong>For a recursive reduction, we have <code>.begin</code>/<code>.loop</code>.</strong> Here’s how it works:</p>
<ol>
<li>Apply <code>.begin</code> to a value of a <code>recursive</code> type.</li>
<li>Apply more operations to the resulting expanded value.</li>
<li>Use <code>.loop</code> on a <em>descendent</em> recursive value, descendent meaning it was a <code>self</code> in
the original value we applied <code>.begin</code> to.</li>
</ol>
<p>Let’s see it in practice. Suppose we want to add up a list of integers.</p>
<ol start="0">
<li>We obtain a value (<code>list</code>) of a recursive type (<code>List&lt;Int&gt;</code>):
<pre><code class="language-par">dec SumList : [List&lt;Int&gt;] Int

def SumList = [list]
</code></pre>
</li>
<li>We apply <code>.begin</code> to it:
<pre><code class="language-par">                     list.begin
</code></pre>
</li>
<li>We match on the possible variants:
<pre><code class="language-par">                               .case {
  .end!       =&gt; 0,
  .item(x) xs =&gt;
</code></pre>
If the list is empty, the result is <code>0</code>. Otherwise, we need to add the number <code>x</code>
<pre><code class="language-par">                 Int.Add(x,
</code></pre>
to the sum of the rest of the list: <code>xs</code>.</li>
<li>Since <code>xs</code> is a <em>descendant</em> of the original <code>list</code> that we applied the <code>.begin</code> to, and is again a
<code>List&lt;Int&gt;</code>, we can recursively obtain its sum using <code>.loop</code>:
<pre><code class="language-par">                            xs.loop),
</code></pre>
And close the braces.
<pre><code class="language-par">}
</code></pre>
</li>
</ol>
<p>All put together, it looks like this:</p>
<pre><code class="language-par">def SumList = [list] list.begin.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.loop),
}
</code></pre>
<p>You can think of <code>.loop</code> as going back to the corresponding <code>.begin</code>, but with the new value.</p>
<p>The semantics of <code>.begin</code>/<code>.loop</code> are best explained by <em>expansion</em>, just like the recursive types
themselves. In all cases, <strong>the meaning of <code>.begin</code>/<code>.loop</code> is unchanged, if we replace each <code>.loop</code> with the entire body starting at <code>.begin</code>.</strong></p>
<p>Observe:</p>
<ol>
<li>The original code:
<pre><code class="language-par">def SumList = [list] list.begin.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.loop),
}
</code></pre>
</li>
<li>The first expansion:
<pre><code class="language-par">def SumList = [list] list.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.begin.case {
    .end!       =&gt; 0,
    .item(x) xs =&gt; Int.Add(x, xs.loop),
  }),
}
</code></pre>
</li>
<li>The second expansion:
<pre><code class="language-par">def SumList = [list] list.case {
  .end!       =&gt; 0,
  .item(x) xs =&gt; Int.Add(x, xs.case {
    .end!       =&gt; 0,
    .item(x) xs =&gt; Int.Add(x, xs.begin.case {
      .end!       =&gt; 0,
      .item(x) xs =&gt; Int.Add(x, xs.loop),
    }),
  }),
}
</code></pre>
</li>
<li>And so on…</li>
</ol>
<p><code>.loop</code> may be applied to any number of descendants. Here’s a function adding up the leafs in the <code>Tree</code>
type defined previously:</p>
<pre><code class="language-par">dec SumTree : [Tree] Int
def SumTree = [tree] tree.begin.case {
  .leaf number        =&gt; number,
  .node(left, right)! =&gt; Int.Add(left.loop, right.loop),
}

def BiggerSum = SumTree(BiggerTree)  // = 20
</code></pre>
<blockquote>
<p><strong>If there are multiple nested <code>.begin</code>/<code>.loop</code>, it may be necessary to
distinguish between them.</strong> Labels can be used here too, just like with the types:
<code>.begin/label</code> and <code>.loop/label</code> does the job.</p>
<p>TODO:</p>
<pre><code class="language-par">type Tree&lt;a&gt; = recursive List&lt;(a) self&gt;
</code></pre>
</blockquote>
<h3 id="retention-of-local-variables"><a class="header" href="#retention-of-local-variables">Retention of local variables</a></h3>
<p>Let’s consider Haskell for a moment. Say we write a simple function that increments each item in
a list by a specified amount:</p>
<pre><code class="language-haskell">incBy n []     = []
incBy n (x:xs) = (x + n) : incBy n xs
</code></pre>
<p>This recursive function has a parameter that has to be remembered across the iterations: <code>n</code>, the
increment. In Haskell, that’s achieved by explicitly passing it to the recursive call.</p>
<p>Now, let’s look at <em>Par</em>. In Par, <code>.loop</code> has a neat feature:
<strong>local variables are automatically passed to the next iteration.</strong></p>
<pre><code class="language-par">dec IncBy : [List&lt;Int&gt;, Int] List&lt;Int&gt;
def IncBy = [list, n] list.begin.case {
  .end!       =&gt; .end!,
  .item(x) xs =&gt; .item(Int.Add(x, n)) xs.loop,
}
</code></pre>
<p>Notice, that <code>xs.loop</code> makes no mention of <code>n</code>, the increment. Yet, <code>n</code> is available throughout the
recursion, because it is automatically passed around.</p>
<p>This feature is what makes <code>begin</code>/<code>loop</code> not just a universal recursion construct, but a sweet spot
between usual recursion and imperative loops.</p>
<blockquote>
<p>If you’re confused about how or why it should work this way, try expanding the <code>.begin</code>/<code>.loop</code>
in the above function. Notice that when expanded, <code>n</code> is in fact visible in the next iteration.
It’s truly the case that expanding a <code>.begin</code>/<code>.loop</code> never changes its meaning.</p>
</blockquote>
<p>Together with <code>.begin</code>/<code>.loop</code> being usable deep in expressions, local variable retention is also
very useful in avoiding the need for helper functions.</p>
<p>Let’s again switch to Haskell, and take a look at this list reversing function:</p>
<pre><code class="language-haskell">reverse list = reverseHelper [] list

reverseHelper acc []     = acc
reverseHelper acc (x:xs) = reverseHelper (x:acc) xs
</code></pre>
<p>This function uses a state: <code>acc</code>, the accumulator. It prepends a new item to it in every iteration,
eventually reversing the whole list. In Haskell, this requires a helper recursive function.</p>
<p>In Par, it doesn’t!</p>
<pre><code class="language-par">dec Reverse : [type a] [List&lt;Int&gt;] List&lt;Int&gt;
def Reverse = [type a] [list]
  let acc: List&lt;a&gt; = .end!
  in list.begin.case {
    .end!       =&gt; acc,
    .item(x) xs =&gt; let acc = .item(x) acc in xs.loop,
  }

def TestReverse = Reverse(type Int)(*(1, 2, 3, 4, 5))  // = *(5, 4, 3, 2, 1)
</code></pre>
<p>And there we go! All we had to do was to re-assign <code>acc</code> with the new value, and continue with <code>xs.loop</code>.</p>
<h3 id="the-escape-hatch-from-totality-unfounded"><a class="header" href="#the-escape-hatch-from-totality-unfounded">The escape-hatch from totality: <code>.unfounded</code></a></h3>
<p>If the Par’s type checker refuses to accept your recursive algorithm despite you being certain it’s
total — meaning it resolves on all inputs — it’s possible to disable the totality checking by
replacing <code>.begin</code> with <code>.unfounded</code>.</p>
<p>Par’s totality checking is currently not powerful enough for some algorithms, especially divide
and conquer, and it’s also lacking when decomposing recursive algorithms into multiple functions.
In such cases, using <code>.unfounded</code> is okay. We do, however, aim to make the type system stronger,
and eventually remove <code>.unfounded</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choice"><a class="header" href="#choice">Choice</a></h1>
<p>The famous slogan of <a href="types/./either.html">sum types</a> is: <strong><em>Make illegal states unrepresentable!</em></strong></p>
<p><em>Choice types</em> — the dual of sum types, also known as <em>codata</em> — deserve an equally potent
slogan:</p>
<blockquote>
<p><strong><em>Make illegal operations unperformable!</em></strong></p>
</blockquote>
<p>Choice types are somewhat related to <em>interfaces</em>, like in Go, or Java, but I encourage you to
approach them with a fresh mind. The differences are important enough to consider choice types
their own thing.</p>
<p>A <em>choice type</em> is defined by a finite number of branches, each with a different name and a result.</p>
<p>Values of a choice type are objects that can (and must) be destructed using one of the available
branches, to obtain its result.</p>
<pre><code class="language-par">type ChooseStringOrNumber = choice {
  .string =&gt; String,
  .number =&gt; Int,
}
</code></pre>
<p>A choice type is spelled with the keyword <code>choice</code>, followed by curly braces enclosing a
comma-separated list of branches.</p>
<p>Each branch has a lower-case name prefixed by a period, followed by <code>=&gt;</code>, and a single obligatory
result type.</p>
<pre><code class="language-par">choice {
  .branch1 =&gt; Result1,
  .branch2 =&gt; Result2,
  .branch3 =&gt; Result3,
}
</code></pre>
<p>If the result is a function, we can use <em>syntax sugar</em>, and move the argument to the left side
of the arrow, inside round parentheses:</p>
<pre><code class="language-par">type CancellableFunction&lt;a, b&gt; = choice {
  .cancel =&gt; !,
  //.apply =&gt; [a] b,
  .apply(a) =&gt; b,
}
</code></pre>
<p>Like <a href="types/./function.html">functions</a>, <strong>choice types are <a href="types/TODO">linear</a>.</strong> A value of a choice type may not be
dropped, or copied. It must be destructed exactly once, using one of its branches.</p>
<blockquote>
<p>Choice types are frequently used together with <a href="types/./iterative.html"><em>iterative</em></a> types to define objects
that can be acted upon repeatedly. For example, the <a href="types/../standard_library.html">built-in</a> <code>Console</code> type
obtained as a handle to print to the standard output is an <em>iterative choice</em>:</p>
<pre><code class="language-par">type Console = iterative choice {
  .close =&gt; !,
  .print(String) =&gt; self,
}
</code></pre>
<p>Then it can be used to print multiple lines in order:</p>
<pre><code class="language-par">def Main = Console.Open
  .print("First line.")
  .print("Second line.")
  .print("Third line.")
  .close
</code></pre>
</blockquote>
<h2 id="construction-6"><a class="header" href="#construction-6">Construction</a></h2>
<p>Values of choice types are constructed using standalone <code>case</code> expressions.</p>
<pre><code class="language-par">def Example: ChooseStringOrNumber = case {
  .string =&gt; "Hello!",
  .number =&gt; 42,
}
</code></pre>
<p>Each branch inside the curly braces follows the same syntax as the branches in the corresponding
type, except with types replaced by their values.</p>
<pre><code class="language-par">def IntToString: CancellableFunction&lt;Int, String&gt; = case {
  .cancel =&gt; !,
  //.apply =&gt; [s] Int.ToString(s),
  .apply(s) =&gt; Int.ToString(s),
}
</code></pre>
<p>Unlike patterns in <code>.case</code> branches of <a href="types/./either.html"><em>either</em> types</a>, branches in <code>case</code>
expressions of choice types don’t have a payload to bind: they produce a result. However, we can
still bind function arguments on the left side of the arrow.</p>
<h2 id="destruction-6"><a class="header" href="#destruction-6">Destruction</a></h2>
<p>Choices are destructed by <em>selecting</em> a branch, transforming it into the corresponding result.
We do it by applying <code>.branch</code> after a value of a choice type.</p>
<pre><code class="language-par">def Number = Example.number  // = 42
</code></pre>
<p>Above, we defined the type <code>CancellableFunction&lt;a, b&gt;</code>, and a value of that type: <code>IntToString</code>.
<a href="types/./function.html">Bare functions</a> are linear, so we must call them, but the <em>cancellable function</em>
gives us a choice of either calling it, or not.</p>
<p>We can use this to define a <em>map</em> function for optional values:</p>
<pre><code class="language-par">type Option&lt;a&gt; = either {
  .none!,
  .some a,
}

dec MapOption :
  [type a, b]
  [Option&lt;a&gt;]
  [CancellableFunction&lt;a, b&gt;]
  Option&lt;b&gt;

def MapOption = [type a, b] [option, func] option.case {
  .none! =&gt; let ! = func.cancel in .none!,
//                  \_________/
  .some x =&gt; let y = func.apply(x) in .some y,
//                   \________/
}

def Result = MapOption(type Int, String)(.some 42, IntToString)  // = .some "42"
</code></pre>
<p>This example also shows that in Par, you don’t have to be shy about writing your types on
multiple lines. The syntax is designed for that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterative"><a class="header" href="#iterative">Iterative</a></h1>
<p>We already covered one kind of self-referential types: <a href="types/./recursive.html"><em>recursive types</em></a>. Now we cover
the other kind: <em>iterative types</em>. They are also known as
<a href="https://en.wikipedia.org/wiki/Coinduction"><em>coinductive</em></a>, or corecursive types, because they enable
<a href="https://en.wikipedia.org/wiki/Corecursion"><em>corecursion</em></a>.</p>
<p>In a nutshell:</p>
<ul>
<li>Values of <strong>recursive types</strong> <em>are</em> something repeated <em>some</em> number of times.</li>
<li>Values of <strong>iterative types</strong> <em>can</em> repeat something <em>any</em> number of times.</li>
</ul>
<p>Recursive types tell you how many times you need to step through them to reach the end. That’s what
<code>.begin</code>/<code>.loop</code> does. If there is a <code>self</code>, you can always <code>.loop</code> through it, and proceed with the
recursion until you reach the end.</p>
<p>But iterative types let you tell <em>them</em> how many times you want to repeat them. They have the ability
to unfold as many times as you like. It’s up to you, the consumer, to proceed.</p>
<p>So, let’s take a look at the <strong>iterative types.</strong></p>
<p>An iterative type starts with the keyword <code>iterative</code> followed by a body that may contain any number
of occurrences of <code>self</code>. Notice that the pattern is the same as with <a href="types/./recursive.html">recursive types</a>.</p>
<p>The prototypical iterative type — and a good example to study — is an infinite sequence.</p>
<pre><code class="language-par">type Sequence&lt;a&gt; = iterative choice {
    .close =&gt; !,
    .next =&gt; (a) self,
}
</code></pre>
<blockquote>
<p><strong>If there are nested <code>iterative</code> (or <a href="types/./recursive.html"><code>recursive</code></a>) types, it may be necessary to
distinguish between them.</strong> For that, we can attach <strong>labels</strong> to <code>iterative</code> and <code>self</code>. That’s
done with a slash: <code>iterative/label</code>, <code>self/label</code>. Any lower-case identifier can be used for the
label.</p>
</blockquote>
<p>Iterative types are <strong>always linear,</strong> regardless of what’s in their bodies. As such, they can’t be
dropped, nor copied.</p>
<p>Notice that we included a <code>.close</code> branch on the inner <a href="types/./choice.html">choice</a>. Since <code>Sequence&lt;a&gt;</code> is
a linear type, there would be no way to get rid of it if it only contained the <code>.next</code> branch.</p>
<p>Just like <a href="types/./recursive.html">recursive types</a>, iterative types can be equated with their <em>expansions</em>:</p>
<ol>
<li>The original definition:
<pre><code class="language-par">type Sequence&lt;a&gt; = iterative choice {
  .close =&gt; !,
  .next =&gt; (a) self,
}
</code></pre>
</li>
<li>The first expansion:
<pre><code class="language-par">type Sequence&lt;a&gt; = choice {
  .close =&gt; !,
  .next =&gt; (a) iterative choice {
    .close =&gt; !,
    .next =&gt; (a) self,
  },
}
</code></pre>
</li>
<li>The second expansion:
<pre><code class="language-par">type Sequence&lt;a&gt; = choice {
  .close =&gt; !,
  .next =&gt; (a) choice {
    .close =&gt; !,
    .next =&gt; (a) iterative choice {
      .close =&gt; !,
      .next =&gt; (a) self,
    },
  },
}
</code></pre>
</li>
<li>And so on…</li>
</ol>
<blockquote>
<p>Just like <a href="types/./recursive.html"><code>recursive</code></a> types, <code>iterative</code> types have an important restriction:
<strong>every <code>self</code> reference for an <code>iterative</code> must be guarded by a <code>choice</code>.</strong> The <code>choice</code> doesn’t
have to be right next to the <code>iterative</code>, but it <em>has</em> to be somewhere in-between <code>iterative</code> and
<code>self</code>:</p>
<pre><code class="language-par">type ValidSequence&lt;a&gt; = iterative (a) choice {
  .close =&gt; !,
  .next =&gt; self,  // Okay. This `self` is guarded by a `choice`.
}

type InvalidSequence&lt;a&gt; = iterative (a) self  // Error! Unguarded `self` reference
</code></pre>
</blockquote>
<p>So, if both <a href="types/./recursive.html">recursive</a> and iterative types can be equated with their expansions,
<strong>what’s the difference?</strong> The difference lies in their construction and destruction:</p>
<ul>
<li><strong>Recursive types</strong> are <strong>constructed step by step</strong> and <strong>destructed by loops</strong>.</li>
<li>But, <strong>iterative types</strong> are <strong>constructed by loops</strong> and <strong>destructed step by step</strong>.</li>
</ul>
<p>Let’s see what that means!</p>
<h2 id="construction-7"><a class="header" href="#construction-7">Construction</a></h2>
<p>Values of iterative types are constructed using standalone <code>begin</code>/<code>loop</code> expressions. They start with
<code>begin</code>, followed by an expression of the body type. Inside this expression, use a standalone <code>loop</code>
in the <code>self</code> places of the body type to go back to the corresponding <code>begin</code>.</p>
<blockquote>
<p>Just like with <a href="types/./recursive.html">recursive’s</a> <code>.begin</code>/<code>.loop</code>, it’s possible to use labels to
distinguish between nested <code>begin</code>/<code>loop</code> (and <code>.begin</code>/<code>.loop</code>) uses. Just use a slash:
<code>begin/label</code> and <code>loop/label</code>.</p>
</blockquote>
<p>Here’s a simple <code>Sequence&lt;Int&gt;</code> that produces the number <code>7</code> forever:</p>
<pre><code class="language-par">dec SevenForever : Sequence&lt;Int&gt;
def SevenForever = begin case {
  .close =&gt; !,
  .next  =&gt; (7) loop,
}
</code></pre>
<p>The <code>.next</code> branch produces a pair, as per the sequence’s body type, with the second element being
the new version of the sequence. Here we use <code>loop</code> to accomplish that corecursively, looping back
to the <code>begin</code>.</p>
<p>The corecursive meaning of <code>begin</code>/<code>loop</code> can again be understood by seeing its expansions:</p>
<ol>
<li>The original code:
<pre><code class="language-par">def SevenForever = begin case {
  .close =&gt; !,
  .next  =&gt; (7) loop,
}
</code></pre>
</li>
<li>The first expansion:
<pre><code class="language-par">def SevenForever = case {
  .close =&gt; !,
  .next  =&gt; (7) begin case {
    .close =&gt; !,
    .next  =&gt; (7) loop,
  },
}
</code></pre>
</li>
<li>The second expansion:
<pre><code class="language-par">def SevenForever = case {
  .close =&gt; !,
  .next  =&gt; (7) case {
    .close =&gt; !,
    .next  =&gt; (7) begin case {
      .close =&gt; !,
      .next  =&gt; (7) loop,
    },
  },
}
</code></pre>
</li>
<li>And so on…</li>
</ol>
<p><strong>Retention of local variables</strong> works the same as in <a href="types/./recursive.html">recursive’s</a> <code>.begin</code>/<code>.loop</code>.
With iterative types, we can use it to carry and <strong>update the internal state</strong> of the iterative object.</p>
<p>For example, here’s an infinite sequence of fibonacci numbers:</p>
<pre><code class="language-par">def Fibonacci: Sequence&lt;Nat&gt; =
  let (a, b)! = (0, 1)!
  in begin case {
    .close =&gt; !,
    .next =&gt;
      let (a, b)! = (b, Nat.Add(a, b))!
      in (a) loop
  }
</code></pre>
<p>This is very useful. In most programming languages, constructing a similar <code>Fibonacci</code> object would
require defining a <code>class</code> or a <code>struct</code> describing the internal state, and then updating it in
methods. In Par, iterative objects can be constructed using anonymous expressions, with no need
of specifying their internal state by a standalone type: <strong>the internal state is just local variables.</strong></p>
<p>In the <code>Fibonacci</code>’s case, the internal state is non-linear. That’s why we’re able to return a bare unit
in the <code>.close</code> branch: <code>a</code> and <code>b</code> get dropped automatically.</p>
<p>Let’s take a look at a case where the internal state is linear! Suppose we need a function that takes
an arbitrary sequence of integers, and increments its items by <code>1</code>, producing a new sequence.</p>
<pre><code class="language-par">dec Increment : [Sequence&lt;Int&gt;] Sequence&lt;Int&gt;
def Increment = [seq] begin case {
  .close =&gt; let ! = seq.close in !,
  .next =&gt;
    let (x) seq = seq.next
    in (Int.Add(x, 1)) loop
}

def FibonacciPlusOne = Increment(Fibonacci)
</code></pre>
<p>In this case, we need to explicitly close the input <code>seq</code> in the <code>.close</code> branch. It’s linear, so
we can’t just drop it.</p>
<h3 id="the-escape-hatch-from-totality-unfounded-1"><a class="header" href="#the-escape-hatch-from-totality-unfounded-1">The escape-hatch from totality: <code>unfounded</code></a></h3>
<p>Just like with <a href="types/./recursive.html#the-escape-hatch-from-totality-unfounded">recursive destruction</a>,
it may happen that your iterative construction is total — meaning it never enters an infinite,
unproductive loop — yet not accepted by Par’s type checker. In such cases, it’s possible to
disable Par’s totality checking by replacing <code>begin</code> with <code>unfounded</code>.</p>
<h2 id="destruction-7"><a class="header" href="#destruction-7">Destruction</a></h2>
<p>Iterative types don’t have any special syntax for destruction. Instead, we just operate on their bodies
directly, as if they were expanded.</p>
<p>For example, here’s a function to take the first element from a sequence and close it:</p>
<pre><code class="language-par">def Head = [type a] [seq: Sequence&lt;a&gt;]
  let (x) seq = seq.next
  in let ! = seq.close
  in x
</code></pre>
<p>Using <a href="types/./recursive.html">recursion</a>, we can destruct an iterative type many times. Here’s a function to
take the first N elements of a sequence and return them in a list:</p>
<pre><code class="language-par">dec Take : [type a] [Nat, Sequence&lt;a&gt;] List&lt;a&gt;
def Take = [type a] [n, seq] Nat.Repeat(n).begin.case {
  .end! =&gt; let ! = seq.close in .end!,
  .step remaining =&gt;
    let (x) seq = seq.next
    in .item(x) remaining.loop
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<p>Par has a <strong>linear type system.</strong> By default, values must be used <strong>exactly once.</strong></p>
<p>But not all values need that kind of discipline. Sometimes, you want to:</p>
<ul>
<li>Pass a function around multiple times.</li>
<li>Discard an unused value.</li>
<li>Compose higher-order utilities freely.</li>
</ul>
<p>That’s where <strong>box types</strong> come in.</p>
<h2 id="non-linear-types--even-without-box"><a class="header" href="#non-linear-types--even-without-box">Non-linear types — even without <code>box</code></a></h2>
<p>Even without box types, some types in Par are already non-linear. These are the <strong>data types:</strong></p>
<ul>
<li><a href="types/./unit.html">Unit</a></li>
<li><a href="types/./either.html">Either</a></li>
<li><a href="types/./pair.html">Pair</a></li>
<li><a href="types/./recursive.html">Recursive</a></li>
<li>All the <a href="types/../structure/primitive_types.html">primitives</a>: <code>Int</code>, <code>Nat</code>, <code>String</code>, <code>Char</code>.</li>
</ul>
<p>Any combination of these is always non-linear — they can be copied and discarded freely.</p>
<p>But types that contain <a href="types/./function.html"><strong>functions,</strong></a> <a href="types/./choice.html"><strong>choices,</strong></a> and other non-data types
are linear — no matter how deeply nested.</p>
<p>Now, consider this: what if you want to <strong>apply a function to each element in a list?</strong></p>
<p>A plain function in Par is linear — it can only be used once. So applying it repeatedly requires a workaround.</p>
<h2 id="reusable-functions-the-hard-way"><a class="header" href="#reusable-functions-the-hard-way">Reusable functions, the hard way</a></h2>
<p>Without <code>box</code>, we can build reusable functions by encoding a usage protocol manually:</p>
<pre><code class="language-par">type Mapper&lt;a, b&gt; = iterative choice {
  .close =&gt; !,
  .apply(a) =&gt; (b) self,
}
</code></pre>
<p>This protocol gives us:</p>
<ul>
<li><code>.apply</code> to use the function.</li>
<li><code>.close</code> to clean up.</li>
</ul>
<p>Here’s a <code>Map</code> function that uses it:</p>
<pre><code class="language-par">dec Map : [type a, b] [List&lt;a&gt;, Mapper&lt;a, b&gt;] List&lt;b&gt;
def Map = [type a, b] [list, mapper] list.begin.case {
  .end! =&gt; let ! = mapper.close in .end!,
  .item(x) xs =&gt; let (x1) mapper = mapper.apply(x) in .item(x1) xs.loop,
}
</code></pre>
<p>And using it:</p>
<pre><code class="language-par">def NumberStrings = Map(type Int, String)(Int.Range(1, 100), begin case {
  .close =&gt; !,
  .apply(n) =&gt; (Int.ToString(n)) loop,
})
</code></pre>
<p>This works — but it’s verbose.</p>
<p>Every reusable function needs to be manually encoded with a protocol like <code>Mapper</code>.
Copying, closing, and chaining all become manual work.</p>
<h2 id="box-types-to-the-rescue"><a class="header" href="#box-types-to-the-rescue">Box types to the rescue</a></h2>
<p>Instead of encoding reusability into the type manually, Par lets you <code>box</code> a value.</p>
<p>A <code>box T</code> is a non-linear version of <strong>any</strong> type <code>T</code>. You can:</p>
<ul>
<li><strong>Copy</strong> a <code>box T</code>.</li>
<li><strong>Drop</strong> a <code>box T</code>.</li>
<li>Pass it around freely.</li>
</ul>
<p>You can construct boxed values using:</p>
<pre><code class="language-par">box &lt;expression&gt;
</code></pre>
<p>This constructs a value of type <code>box T</code>, where <code>T</code> is the type of the expression.</p>
<p>The only rule is: <strong>You can only capture non-linear variables in a <code>box</code> expression.</strong></p>
<p>That includes:</p>
<ul>
<li>Data types (<code>Int</code>, <code>String</code>, <code>List&lt;Int&gt;</code>, etc.)</li>
<li>Other <code>box</code> values.</li>
</ul>
<p>The word <em><strong>capture</strong></em> here refers to <em>using local variables</em> inside the expression that were
<em>created outside of that expression.</em></p>
<h2 id="a-better-map"><a class="header" href="#a-better-map">A better <code>Map</code></a></h2>
<p>With <code>box</code>, we can rewrite the <code>Map</code> function much more cleanly:</p>
<pre><code class="language-par">dec Map : [type a, b] [List&lt;a&gt;, box [a] b] List&lt;b&gt;
def Map = [type a, b] [list, f] list.begin.case {
  .end! =&gt; .end!,
  .item(x) xs =&gt; .item(f(x)) xs.loop,
}
</code></pre>
<p>Let’s try it out:</p>
<pre><code class="language-par">def NumberStrings = Map(type Int, String)(
  Int.Range(1, 100),
  box Int.ToString,
)
</code></pre>
<p>No wrappers, no manual protocols. The boxed function can be used freely, because the <code>box</code> type makes
it non-linear. This is exactly what <code>box</code> was made for.</p>
<h2 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h2>
<p>Boxed types fit naturally into Par’s subtyping.</p>
<p><strong>A <code>box T</code> can be used anywhere a <code>T</code> is expected.</strong></p>
<pre><code class="language-par">def BoxInt: box Int = 42       // OK: Int is non-linear
def UseInt: Int = BoxInt       // OK: box Int can be used as Int
</code></pre>
<p>And <strong>if <code>T</code> is already non-linear, then <code>T</code> can be used anywhere a <code>box T</code> is expected.</strong></p>
<pre><code class="language-par">def Boxes: List&lt;box Int&gt; = *(1, 2, 3)
def Ints: List&lt;Int&gt; = Boxes
</code></pre>
<p><strong>For non-linear types, <code>T</code> and <code>box T</code> are effectively interchangeable.</strong></p>
<h2 id="another-example-filtering-a-list"><a class="header" href="#another-example-filtering-a-list">Another example: Filtering a list</a></h2>
<p>Let’s write a function that filters a list using a boxed predicate.</p>
<pre><code class="language-par">dec Filter : [type a] [List&lt;box a&gt;, box [a] Bool] List&lt;a&gt;

def Filter = [type a] [list, predicate] list.begin.case {
  .end! =&gt; .end!,
  .item(x) xs =&gt; predicate(x).case {
    .true! =&gt; .item(x) xs.loop,
    .false! =&gt; xs.loop,
  }
}
</code></pre>
<p>Note the types:</p>
<ul>
<li>We accept a list of <code>box a</code>, because elements might be discarded.</li>
<li>But we return a <code>List&lt;a&gt;</code> — not a <code>List&lt;box a&gt;</code>.</li>
</ul>
<p>Let’s try it out:</p>
<pre><code class="language-par">def Evens = Filter(type Int)(
  Int.Range(1, 100),
  box [n] Int.Equals(0, Int.Mod(n, 2)),
)
</code></pre>
<p>Here:</p>
<ul>
<li><code>Int.Range(1, 100)</code> gives a <code>List&lt;Int&gt;</code>, which is valid because <code>Int</code> can be used as a <code>box Int</code>.</li>
<li>The result is inferred as <code>List&lt;Int&gt;</code>, not <code>List&lt;box Int&gt;</code>.</li>
</ul>
<p>This avoids bloating the result type with redundant boxes — keeping things clear.</p>
<p>And if we were filtering a list of boxed values already?</p>
<pre><code class="language-par">Filter(type box T)(listOfBoxT, predicate)
</code></pre>
<p>That works too. Thanks to subtyping, everything lines up as you’d expect.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exists"><a class="header" href="#exists">Exists</a></h1>
<p>An <em>exists type</em> lets a value <strong>hide a type inside itself</strong> — while exposing only what can be done
with that type.</p>
<p>They’re the dual of the parametric types: <a href="types/./forall.html"><em>forall</em></a>. A forall type <code>[type a] ...</code> says:
<em>“You can give me any type <code>a</code>, and I’ll work with it.”</em> On the other hand, an <em>exists type</em> <code>(type a) ...</code>
says: <em>“I have chosen some specific type <code>a</code>, but I’m not going to tell you what it is.”</em></p>
<p>An exists type <strong>consists of two parts:</strong></p>
<ul>
<li>A lowercase type variable enclosed in round parentheses, prefixed with the keyword <code>type</code>.</li>
<li>The payload type — a type that may use the hidden type variable.</li>
</ul>
<p>It’s similar to a <a href="types/./pair.html">pair</a>, but the first component is a type instead of a value.</p>
<p>Here are two simple examples of existential types:</p>
<pre><code class="language-par">type Any = (type a) a

type DropMe = (type a) (a) choice {
  .drop(a) =&gt; !,
}
</code></pre>
<p>The first one is completely opaque — a value of <code>Any</code> gives you a value of the hidden type, but no
operations to perform on it. That makes it useless, but it’s the simplest example of an exists type.</p>
<p>The second one offers just one operation: dropping a value of that type.
It gives us a pair: a value of the hidden type, plus a <a href="types/./choice.html">choice</a> with just one operation:
dropping a value of that type.</p>
<p>Let’s now see how existential types are used.</p>
<h2 id="construction-8"><a class="header" href="#construction-8">Construction</a></h2>
<p>To construct an existential value, you must pick a concrete type and provide a matching payload.</p>
<p>The syntax is the same as for <a href="types/./pair.html">pairs</a>, with the addition of the <code>type</code> keyword.</p>
<p>Here’s a value of type <code>Any</code>:</p>
<pre><code class="language-par">def Hidden: Any = (type Int) 42
</code></pre>
<p>But since the type is hidden inside <code>Any</code>, with no operations provided, this value is completely useless —
we can’t do anything with it. In fact, we can’t even get rid of it, if we were to instantiate it into a
variable.</p>
<p>Let’s now look at a slightly more interesting example:</p>
<pre><code class="language-par">type DropMe = (type a) (a) choice {
  .drop(a) =&gt; !,
}
</code></pre>
<p>The payload here is a pair: a value of the hidden type, plus a <a href="types/./choice.html">choice</a> with just one operation:
dropping a value of that type.</p>
<p>Here’s how we can construct a value of <code>DropMe</code>:</p>
<pre><code class="language-par">def Drop42: DropMe = (type Int) (42) case {
  .drop(n) =&gt; !,  // `n`, being an `Int`, is dropped by being unused
}
</code></pre>
<h2 id="destruction-8"><a class="header" href="#destruction-8">Destruction</a></h2>
<p>To use an existential value, you must <strong>unpack it</strong>. The syntax is the same as unpacking a pair,
just with the type keyword.</p>
<p>Here’s an example that unpacks and uses a <code>DropMe</code>:</p>
<pre><code class="language-par">def UseDrop: ! =
  let (type a) (x) dropper = Drop42
  in dropper.drop(x)
</code></pre>
<p>The pattern <code>(type a) (x) dropper</code> means:</p>
<ul>
<li><code>a</code> becomes the name of the hidden type, a local type variable.</li>
<li><code>x</code> is the stored value of type <code>a</code>.</li>
<li><code>dropper</code> is the <a href="types/./choice.html">choice</a> with the <code>.drop</code> method.</li>
</ul>
<p>We can also unpack existentials <strong>in function parameters,</strong> using patterns. Here’s a function that takes
a <code>DropMe</code> and drops its inner value:</p>
<pre><code class="language-par">dec DropIt : [DropMe] !
def DropIt = [(type a) (x) dropper] dropper.drop(x)
</code></pre>
<h2 id="a-real-example"><a class="header" href="#a-real-example">A Real Example</a></h2>
<p><em>Exists</em> types become truly useful when combined with <a href="types/./box.html">box</a> types — allowing you to hide
implementation details inside interfaces that can be passed around freely.</p>
<p>Here’s a boxed interface for working with sets:</p>
<pre><code class="language-par">type SetModule&lt;a&gt; = (type set) box choice {
  .empty =&gt; box set,
  .insert(a, box set) =&gt; box set,
  .contains(a, box set) =&gt; Bool,
}
</code></pre>
<p>This type hides the implementation type of the set.
The interface is boxed, so it can be copied and discarded.
The hidden type <code>set</code> is never revealed — only its operations are exposed.</p>
<p>Let’s now implement an inefficient, but simple <code>SetModule</code> using lists and equality functions:</p>
<pre><code class="language-par">type Eq&lt;a&gt; = box [a, a] Bool

dec ListSet : [type a] [Eq&lt;box a&gt;] SetModule&lt;box a&gt;
def ListSet = [type a] [eq] (type List&lt;box a&gt;) box case {
  .empty =&gt; .end!,

  .insert(x, set) =&gt; .item(x) set,

  .contains(y, set) =&gt; set.begin.case {
    .end! =&gt; .false!,
    .item(x) xs =&gt; eq(x, y).case {
      .true! =&gt; .true!,
      .false! =&gt; xs.loop,
    },
  },
}
</code></pre>
<p>This implementation of sets can only be constructed for non-linear types. That’s what <code>box a</code> ensures here.</p>
<p>We construct the existential by choosing <code>List&lt;box a&gt;</code> as the hidden type:</p>
<pre><code class="language-par">(type List&lt;box a&gt;) ...
</code></pre>
<p>The consumer of the <code>SetModule</code> doesn’t know that these sets are implemented as lists.</p>
<p>Let’s now use that in a function:</p>
<pre><code class="language-par">dec Deduplicate : [type a] [SetModule&lt;a&gt;, List&lt;box a&gt;] List&lt;a&gt;
def Deduplicate = [type a] [(type set) mSet, list]
  let visited = mSet.empty
  in list.begin.case {
    .end! =&gt; .end!,
    .item(x) xs =&gt; mSet.contains(x, visited).case {
      .true! =&gt; xs.loop,
      .false! =&gt;
        let visited = mSet.insert(x, visited)
        in .item(x) xs.loop,
    }
  }
</code></pre>
<p>This function deduplicates a list by tracking seen values using a hidden set implementation.
It doesn’t know how the set works — just that it supports <code>.empty</code>, <code>.insert</code>, and <code>.contains</code>.</p>
<p>Let’s test it!</p>
<pre><code class="language-par">dec Map : [type a, b] [box [a] b, List&lt;a&gt;] List&lt;b&gt;
def Map = [type a, b] [f, list] list.begin.case {
  .end! =&gt; .end!,
  .item(x) xs =&gt; .item(f(x)) xs.loop,
}

def IntListSet = ListSet(type Int)(box Int.Equals)

def TestDedup =
  Deduplicate(type Int)(IntListSet)
    (Map(type Int, Int)(box [n] Int.Mod(n, 7), Int.Range(1, 1000)))
</code></pre>
<p>This deduplicates a list of numbers modulo 7 — using:</p>
<ul>
<li><code>Map</code> to apply the modulo.</li>
<li><code>ListSet</code> to get an abstract set implementation.</li>
<li><code>Deduplicate</code> to do the filtering.</li>
</ul>
<p>All without exposing how the set is represented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuation"><a class="header" href="#continuation">Continuation</a></h1>
<p>The <em>continuation</em> type — spelled <code>?</code> — is the <a href="types/../processes/duality.html">dual</a> of <a href="types/./unit.html">unit</a>.
It has <strong>no expression syntax</strong> whatsoever — it’s only usable in <a href="types/../process_syntax.html">processes</a>.
Turn the page to learn all about that!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-process-syntax"><a class="header" href="#the-process-syntax">The Process Syntax</a></h1>
<p>So far, <em>Par</em> seems clearly a functional language. Yes, it has linear types, and some unusual
features, like <a href="./types/choice.html">choices</a>, and <code>begin</code>/<code>loop</code> for
<a href="./types/recursive.html">recursive</a> and <a href="./types/iterative.html">iterative</a> types, instead of the
usual recursion by name. But, it’s still clearly a functional language.</p>
<p>However, it is not! <strong>At its core, Par is a <em>process language!</em></strong> While functional languages
are ultimately based on <a href="https://en.wikipedia.org/wiki/Lambda_calculus"><em>λ-calculus</em></a>, Par is
based on <em>CP</em>, a process language similar to <a href="https://en.wikipedia.org/wiki/%CE%A0-calculus"><em>π-calculus</em></a>.
Process languages are not based on expressions. Instead, they work with concurrent processes,
channels, and operations on them, like sending, and receiving. <em>CP</em> was formulated by
<a href="https://en.wikipedia.org/wiki/Philip_Wadler">Phil Wadler</a>, an influential computer scientist,
in his wonderful paper called <a href="https://www.pure.ed.ac.uk/ws/portalfiles/portal/18383989/Wadler_2012_Propositions_as_Sessions.pdf"><em>“Propositions as Sessions”</em></a>. It was not intended to become a basis
for a practical programming language; <em>GV</em> — a functional language in the same paper — was supposed
to take that role. However, I saw much more potential in <em>CP</em>, and decided to turn it into
a practical language.</p>
<p>How is it then that Par managed to look perfectly functional until now? Turns out,
<strong>all of the <em>construction</em> and <em>destruction</em> syntax described in <a href="./types.html"><em>Types &amp; Their Expressions</em></a> can actually be considered a syntax sugar over the fundamental process syntax of Par</strong>.</p>
<p>While most of the Par code you’ll be writing will use <em>expression syntax</em>, the full power of the
language rests in the <em>process syntax</em>. There are things Par can express, which simply are not
expressible using the constructs we learned thus far.</p>
<h2 id="what-even-is-a-process-language"><a class="header" href="#what-even-is-a-process-language">What Even Is a Process Language?</a></h2>
<p>The most famous process language is undoubtedly <a href="https://en.wikipedia.org/wiki/%CE%A0-calculus"><em>π-calculus</em></a>. In general, a process
language consists of:</p>
<ul>
<li><strong>Processes.</strong> These are independent units of control flow, that execute concurrently, and interact by communication.</li>
<li><strong>Channels.</strong> That’s where communication happens. Two processes that hold opposite ends of the same channel can use it
to exchange information, or even other channels.</li>
<li><strong>Commands.</strong> Processes run by executing commands, those are their code. A command says what interaction to perform on a channel:
what to send, what to receive.</li>
</ul>
<p>From among these, we have already encountered one in Par: <em>channels</em>. That’s because aside from
<a href="./structure/primitive_types.html">primitives</a>, <strong>all values in Par are channels.</strong> Yes,
<a href="./types/function.html">functions</a>, <a href="./types/pair.html">pairs</a>, <a href="./types/choice.html">choices</a>, all of them. It will become much
clearer as we understand this process syntax.</p>
<p>Processes and commands have been more hidden, so far. They were always there, but not in a plain sight! Any expression, be
it a construction, or a destruction, compiled to processes composed of commands.</p>
<p>In fact, you can see it for yourself! Let’s take any Par program, say <code>examples/HelloWorld.par</code>.</p>
<pre><code class="language-par">def Program = Console.Open
  .print("Hello, world!")
  .close
</code></pre>
<p>Open it in the playground, press <strong>Compile</strong>, then enable the <strong>✔️ Show compiled</strong> checkbox:</p>
<p><img src="./images/process_syntax_1.png" alt="Hello World compiled to process syntax" /></p>
<p>What you see on the right is the same program rewritten using the most bare-bones process syntax that Par offers.
Aside from the <code>#</code>-signs in front of some variables (Par uses them for internally generated variables to avoid
name clashes), this is a valid Par program. If we remove those, we get this:</p>
<pre><code class="language-par">def Program = chan result {
  let object = Console.Open
  object.print
  object("Hello, world!")
  object.close
  result &lt;&gt; object
}
</code></pre>
<p>Copy-paste it into the playground and run it! It’s the same program.</p>
<h2 id="isnt-the-expression-syntax-enough-why-complicate-things"><a class="header" href="#isnt-the-expression-syntax-enough-why-complicate-things">Isn’t the expression syntax enough? Why complicate things?</a></h2>
<p>First of all, it is in fact not enough. Not all Par programs are expressible using pure expression syntax, that we’ve learned
fully thus far.</p>
<p>But even more importantly, <strong>process syntax can make your programs much nicer.</strong> It’s not a hammer to be used all the time!
Instead, it’s a feature that has to be carefully combined with expression syntax and used when appropriate. Par offers syntax
features to <strong>seamlessly switch between expressions and processes,</strong> so that you can always apply that which fits best, granularly.</p>
<p>Sprinkles of process syntax tend to be a particularly good fit when dealing with <a href="./types/choice.html">choices</a> and
<a href="./types/iterative.html">iteratives</a>. Take this function that zips two infinite sequences:</p>
<pre><code class="language-par">type Sequence&lt;a&gt; = iterative choice {
  .close =&gt; !,
  .next =&gt; (a) self,
}

dec Zip : [type a, b] [Sequence&lt;a&gt;, Sequence&lt;b&gt;] Sequence&lt;(a, b)!&gt;
def Zip = [type a, b] [seq1, seq2] begin case {
  .close =&gt;
    let ! = seq1.close in
    let ! = seq2.close in !,

  .next =&gt;
    let (x) seq1 = seq1.next in
    let (y) seq2 = seq2.next in
    ((x, y)!) loop,
}
</code></pre>
<p>It takes two sequences, one of <code>a</code>s and one of <code>b</code>s, and produces a new sequence of pairs <code>(a, b)!</code>. When asked to close, it
closes the two underlying sequences as well — it must, they are linear. When asked for the next item, it polls both sequences
for their respective items and yields a pair of that.</p>
<p>It works, and is understandable. But, it can be even better, when we apply some process syntax!</p>
<pre><code class="language-par">dec Zip : [type a, b] [Sequence&lt;a&gt;, Sequence&lt;b&gt;] Sequence&lt;(a, b)!&gt;
def Zip = [type a, b] [seq1, seq2] begin case {
  .close =&gt; do {
    seq1.close
    seq2.close
  } in !,

  .next =&gt; do {
    seq1.next[x]
    seq2.next[y]
  } in ((x, y)!) loop,
}
</code></pre>
<p>It might not look better on the first sight, due to unfamiliarity. But notice, this version is much less cluttered. Instead
of explicitly re-assigning <code>seq1</code> and <code>seq2</code>, we simply command them to give us their items. They automatically update in-place.</p>
<p>Here’s where <a href="https://en.wikipedia.org/wiki/Session_type"><strong>session types</strong></a> come in. We now treat <code>seq1</code> as a channel. First,
we notify it of our intention with the <code>.next</code> signal. Then, we receive an item and save it to a variable with <code>[x]</code>. The
resemblance to the <a href="./types/function.html#construction">construction syntax of functions</a> is not a coincidence!</p>
<p><strong>Now, let’s learn what this process syntax is all about!</strong> We’ll start by gradually enriching our programs with some commands,
all the way to unlocking the full semantics of Par by exploiting <strong>duality.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-do-expression"><a class="header" href="#the-do-expression">The <code>do</code> Expression</a></h1>
<p>Most of the time, it’s not desirable to use <em>process syntax</em> for the whole program. Instead, it’s usually best to
just insert some commands where appropriate. That’s what the <code>do</code> expression is all about. In real Par programs,
<strong>most of the explicit commands will be found in <code>do</code> expressions.</strong> And, since we’re already familiar with
<em>expression syntax</em>, <code>do</code> expressions are a good place to start adding commands to otherwise expression-based programs.</p>
<p>A <code>do</code> expression starts with the keyword <code>do</code>, then a sequence of commands (without separators) enclosed in
curly braces, followed by the keyword <code>in</code>, and finally the resulting expression.</p>
<p>It executes the commands first, then evaluates to the expression after <code>in</code>.</p>
<pre><code class="language-par">def MyName: String = do { } in "Michal"
</code></pre>
<p>The above <code>do</code> expression contains no commands, so its result is simply <code>"Michal"</code>.</p>
<h2 id="the-let-statement"><a class="header" href="#the-let-statement">The <code>let</code> Statement</a></h2>
<p>Before getting onto actual commands — those that manipulate channels — there is one non-command that can occur in
a process: the <code>let</code> statement. Just like the <a href="processes/../structure/let_expressions.html"><code>let</code>/<code>in</code> expression</a>, it assigns
a variable. The only difference is: the <code>let</code> statement doesn’t contain the <code>in</code> keyword. And, since it’s a process,
there can be more of them one after another.</p>
<pre><code class="language-par">dec DisplayPlusEquation : [Nat, Nat] String
def DisplayPlusEquation = [a, b] do {
  let c = Nat.Add(a, b)
  let a = Int.ToString(a)
  let b = Int.ToString(b)
  let c = Int.ToString(c)
} in String.Builder.add(a).add("+").add(b).add("=").add(c).build

def Test = DisplayPlusEquation(3, 4)  // = "3+4=7"
</code></pre>
<p>This is, in fact, the <strong>idiomatic way to assign multiple variables in an expression.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>A process is a sequence of commands, and <code>let</code> statements. Now that we’ve covered
<a href="processes/./do_expression.html#the-let-statement"><code>let</code> statements</a>, it’s time to look at commands. We’ll do
that by using them in small, but realistic examples.</p>
<p>First, <strong>what even is a command?</strong> It’s similar to a statement in imperative programming, but there
is an important difference. In imperative programming, a statement is usually an expression
that’s evaluated not for its result, but for its side-effects. In contrast, commands in Par are
<em>not</em> expressions, they are a distinct syntactic category.</p>
<p>Every command has a <strong>subject,</strong> a channel — usually a local variable — that the command is
operating on. After executing the command, the subject <strong>changes its type.</strong> This is the important
distinction from imperative statements. It’s the distinction that brings proper, and ergonomic
session typing to this imperative-looking process syntax.</p>
<p><strong>Let’s see that in action!</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selecting--sending"><a class="header" href="#selecting--sending">Selecting &amp; Sending</a></h1>
<p>The built-in <code>String.Builder</code> type is defined this way:</p>
<pre><code class="language-par">type String.Builder = iterative choice {
  .add(String) =&gt; self,
  .build =&gt; String,
}
</code></pre>
<p>It’s basically an object, in an OOP-fashion, with two methods: <code>.add</code> and <code>.build</code>. At the top
level, it’s an <a href="processes/commands/../types/iterative.html">iterative</a> <a href="processes/commands/../types/choice.html">choice</a>: an object that
can be repeatedly interacted with.</p>
<p>We construct an empty <code>String.Builder</code> using the built-in definition of the same name:</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  // code continued below...
</code></pre>
<h2 id="selection"><a class="header" href="#selection">Selection</a></h2>
<p>Now, we have a local variable <code>builder</code> of the type <code>String.Builder</code>.</p>
<p>When learning about <a href="processes/commands/../types/iterative.html">iterative</a> types, we learned that we can treat them
as their underlying body. For <code>String.Builder</code>, it’s a <strong>choice type,</strong> and the command for those is
the <strong>selection command.</strong></p>
<p>All commands start with their subject. Here it’s the <code>builder</code> variable. The selection command
itself then looks the same as the usual <a href="processes/commands/../types/choice.html#destruction">destruction of a choice</a>.</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  builder.add        // selection command
  // code continued below...
</code></pre>
<p>That’s it! Now, here’s the crucial bit: after selection, <code>builder</code> <strong>changes its type</strong> to the type
of the selected branch. Here’s the one we selected:</p>
<pre><code class="language-par">  .add(String) =&gt; self,
</code></pre>
<p>The argument on the left side of <code>=&gt;</code> is just a syntax sugar for a <a href="processes/commands/../types/function.html">function</a>.
De-sugared, it is:</p>
<pre><code class="language-par">  .add =&gt; [String] self,
</code></pre>
<p>Therefore, the type of <code>builder</code> after this <code>builder.add</code> command becomes a function:</p>
<pre><code class="language-par">builder: [String] iterative choice {
  .add(String) =&gt; self,
  .build =&gt; String,
}
</code></pre>
<blockquote>
<p>The <code>self</code> in the original branch got replaced by its corresponding <code>iterative</code> — in
this case, the original <code>String.Builder</code>.</p>
</blockquote>
<h2 id="sending"><a class="header" href="#sending">Sending</a></h2>
<p>For a <strong>function type,</strong> we have the <strong>send command.</strong> It’s just like a function call — but
as a command, it doesn’t have a result. Instead, it turns the subject itself to the result.</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  builder.add        // selection command
  builder("Hello")   // send command
</code></pre>
<blockquote>
<p>You may have noticed, that the <strong>selection</strong> and <strong>send</strong> commands behave the same as a
combination of a regular destruction and re-assignment of the variable. In code:</p>
<pre><code class="language-par">  let builder = builder.add
  let builder = builder("Hello")
</code></pre>
<p>For these two, the behavior matches perfectly! It’s a good way to build intuition about what
these commands mean. However, this simple translation stops working as we get into the <em><code>.case</code></em>
and <em>receive</em> commands.</p>
</blockquote>
<p>After sending the string, <code>builder</code> turns back into the original <code>String.Builder</code>, so we can
keep adding more content to it.</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  builder.add        // selection command
  builder("Hello")   // send command
  builder.add        // selection command
  builder(", ")      // send command
  builder.add        // selection command
  builder("World")   // send command
  builder.add        // selection command
  builder("!")       // send command
</code></pre>
<h2 id="chaining-commands"><a class="header" href="#chaining-commands">Chaining commands</a></h2>
<p>This is rather noisy, but we can improve it! Multiple consecutive <strong>commands on the same subject,</strong>
can be <strong>chained</strong> together, without repeating the subject.</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  builder.add("Hello")
  builder.add(", ")
  builder.add("World")
  builder.add("!")
</code></pre>
<p>Or even:</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  builder
    .add("Hello")
    .add(", ")
    .add("World")
    .add("!")
</code></pre>
<p>I like the first variant better, though.</p>
<p>To complete the <code>do</code> expression, let’s just return the constructed string:</p>
<pre><code class="language-par">def LetsBuildStrings = do {
  let builder = String.Builder
  builder.add("Hello")
  builder.add(", ")
  builder.add("World")
  builder.add("!")
} in builder.build  // = "Hello, world!"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="looping--branching"><a class="header" href="#looping--branching">Looping &amp; Branching</a></h1>
<p>We’ve now seen how commands work with <a href="processes/commands/../types/choice.html">choice types</a> (via selection),
and <a href="processes/commands/../types/function.html">function types</a> (via sending). But those aren’t the only types that
come with their own command styles. Every type does.</p>
<p>Let’s turn our attention to something more intricate: <strong>recursive types.</strong></p>
<p>Take this familiar definition:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
<p>The <code>List</code> type is <a href="processes/commands/../types/recursive.html">recursive</a>, and contains an
<a href="processes/commands/../types/either.html"><code>either</code></a>, and within that, a <a href="processes/commands/../types/pair.html">pair</a>.</p>
<p>To work with such a structure in process syntax, we’ll need to combine three kinds of commands:</p>
<ul>
<li><code>.begin</code> and <code>.loop</code> for recursion,</li>
<li><code>.case</code> branching on the either,</li>
<li>And <code>value[variable]</code> for receiving (peeling off) a value from a pair.</li>
</ul>
<p>We’re now going to demonstrate all of these by implementing a string concatenation function.</p>
<pre><code class="language-par">dec Concat : [List&lt;String&gt;] String
</code></pre>
<p>This function takes a list of strings, and returns them concatenated. We’ll use process syntax and
see how it works out!</p>
<pre><code class="language-par">def Concat = [strings] do {
  // code continued below...
</code></pre>
<p><strong>Let’s go step by step!</strong></p>
<h2 id="recursion-in-processes"><a class="header" href="#recursion-in-processes">Recursion in processes</a></h2>
<p>We start by telling the process: <em>“Hey, we’re about to work with a recursive value!”</em></p>
<p>That’s what <code>.begin</code> does. It establishes a looping point, to which we can jump back later
using <code>.loop</code>.</p>
<pre><code class="language-par">  strings.begin
</code></pre>
<h2 id="branching"><a class="header" href="#branching">Branching</a></h2>
<p>The <code>.case</code> command behaves similarly to expression-based <code>.case</code>, but with two key differences:
In process syntax, the <strong>body</strong> of each <code>.case</code> branch <strong>is a process, not a value.</strong></p>
<p>This means the syntax requires curly braces after the <code>=&gt;</code>. You do something in each branch —
not return something.</p>
<pre><code class="language-par">  strings.case {
    .end! =&gt; {
      // empty list, nothing to do
    }
    .item =&gt; {
</code></pre>
<p>There’s another key difference: notice the <code>.item</code> branch has <code>=&gt;</code> right after the branch name!
There’s no pattern. That’s because in process syntax, binding the payload of an
<a href="processes/commands/../types/either.html">either</a> is optional. Normally, <strong>the subject itself becomes the payload.</strong>
However, it is possible to match the payload fully, if desired.</p>
<p>So, inside the <code>.item</code> branch, <code>strings</code> now has the type <code>(String) List&lt;String&gt;</code> — it’s a pair, and
we want to peel off its first part, to add it to the string builder.</p>
<p>There’s <strong>one last important detail,</strong> and that’s concerning <strong>control flow.</strong> If a <code>.case</code>
branch process does not end (we’ll learn about ending processes in the section about
<a href="processes/commands/../chan_expression.html"><code>chan</code> expressions</a>), then it proceeds to the next line after the closing
parenthesis of the <code>.case</code> command. All local variables are kept.</p>
<h2 id="receiving"><a class="header" href="#receiving">Receiving</a></h2>
<p>To peel a value from a pair, we use the <strong>receive command:</strong></p>
<pre><code class="language-par">      strings[str]
</code></pre>
<p>This command says:
<em>“Take the first part of the pair and store it in <code>str</code>. Keep the rest as the new value of <code>strings</code>.”</em></p>
<p>Now we can assemble the basic skeleton:</p>
<pre><code class="language-par">def Concat = [strings] do {
  let builder = String.Builder
  strings.begin.case {
    .end! =&gt; {
      // nothing to do
    }
    .item =&gt; {
      strings[str]
      builder.add(str)
      strings.loop
    }
  }
} in builder.build
</code></pre>
<p>This looks <em>very</em> imperative! The variable <code>strings</code> flows through the process —
branching, unwrapping, and looping — without needing to be reassigned. It performs all the
different operations based on its changing type. Meanwhile, <code>builder</code> accumulates the result,
tagging along the control flow of <code>strings</code>.</p>
<h2 id="patterns-in-case-branches"><a class="header" href="#patterns-in-case-branches">Patterns in <code>.case</code> branches</a></h2>
<p>The <code>.item =&gt;</code> branch can be made a little more pleasant. If the subject after .begin is a
<a href="processes/commands/../types/pair.html">pair</a>, we’re allowed to use pattern matching directly in the <code>.case</code> branch.</p>
<p>That means this:</p>
<pre><code class="language-par">    .item =&gt; {
      strings[str]
      builder.add(str)
      strings.loop
    }
</code></pre>
<p>Can be rewritten as:</p>
<pre><code class="language-par">    .item(str) =&gt; {
      builder.add(str)
      strings.loop
    }
</code></pre>
<p>Which is exactly what we’ll do in the final version:</p>
<pre><code class="language-par">dec Concat : [List&lt;String&gt;] String
def Concat = [strings] do {
  let builder = String.Builder
  strings.begin.case {
    .end! =&gt; {}
    .item(str) =&gt; {
      builder.add(str)
      strings.loop
    }
  }
} in builder.build

def TestConcat = Concat(*("A", "B", "C"))  // = "ABC"
</code></pre>
<p>This beautifully ties together all the commands we’ve covered so far:</p>
<ul>
<li><strong>Selection</strong> for <a href="processes/commands/../types/choice.html">choices</a>.</li>
<li><strong>Sending</strong> for <a href="processes/commands/../types/function.html">functions</a>.</li>
<li><strong>Branching</strong> for <a href="processes/commands/../types/either.html">eithers</a>.</li>
<li><strong>Receiving</strong> for <a href="processes/commands/../types/pair.html">pairs</a>. Here, in the form of a pattern.</li>
</ul>
<p>The <em>receive commands</em> is the least clearly useful here. Let’s move to infinite sequences to see a
more compelling use-case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receiving-where-it-shines"><a class="header" href="#receiving-where-it-shines">Receiving, Where It Shines</a></h1>
<p>The previous section showed the <code>value[variable]</code> receive command — but it didn’t feel essential.
Let’s now explore a use-case where this command really shines: polling values from an
infinite sequence.</p>
<p>You may remember the <code>Sequence&lt;a&gt;</code> type from earlier. Here’s the definition again:</p>
<pre><code class="language-par">type Sequence&lt;a&gt; = iterative choice {
  .close =&gt; !,
  .next =&gt; (a) self,
}
</code></pre>
<p>A <code>Sequence</code> can generate an unbounded number of values, one by one, and eventually be closed.</p>
<h2 id="a-fibonacci-sequence-as-a-value"><a class="header" href="#a-fibonacci-sequence-as-a-value">A Fibonacci sequence, as a value</a></h2>
<p>Let’s start by building a sequence of Fibonacci numbers.</p>
<pre><code class="language-par">dec Fibonacci : Sequence&lt;Nat&gt;
def Fibonacci =
  let (a) b = (0) 1
  in begin case {
    .close =&gt; !
    .next =&gt;
      let (a) b = (b) Nat.Add(a, b)
      in (a) loop
  }
</code></pre>
<p>The internal state of the sequence is a pair <code>(a) b</code>. On each <code>.next</code>, we emit <code>a</code> and update
the pair. This is a clean and elegant use of corecursive iteration, as we’ve covered it in the
section on <a href="processes/commands/../types/iterative.html">iterative types</a>.</p>
<p>So far so good — but how do we use this value?</p>
<h2 id="goal-print-the-first-30-fibonacci-numbers"><a class="header" href="#goal-print-the-first-30-fibonacci-numbers">Goal: print the first 30 Fibonacci numbers</a></h2>
<p>Let’s say we want to print the first 30 Fibonacci numbers to the terminal.</p>
<p>That means:</p>
<ol>
<li>Repeating an action 30 times,</li>
<li>Receiving a number from the sequence each time,</li>
<li>Converting it to a string,</li>
<li>Sending it to the output.</li>
</ol>
<p>We’ll need a way to loop <strong>exactly 30 times.</strong> But there’s a catch: In Par,
<strong>looping is only possible on recursive types.</strong> There’s no built-in recursion on <code>Nat</code>, so we need
to convert the number 30 into a <a href="processes/commands/../types/recursive.html">recursive</a>.</p>
<p>Good news: there’s a built-in helper for that! It’s called <code>Nat.Repeat</code>, here’s its type:</p>
<pre><code class="language-par">dec Nat.Repeat : [Nat] recursive either {
  .end!,
  .step self,
}
</code></pre>
<p>Calling <code>Nat.Repeat(30)</code> gives us a recursive value that can be stepped through exactly 30 times.
Precisely what we need.</p>
<p>Now for the second part: printing.</p>
<h2 id="console-output"><a class="header" href="#console-output"><code>Console</code> output</a></h2>
<p>Par comes with a built-in definition for working with standard output:</p>
<pre><code class="language-par">def Console.Open : Console
</code></pre>
<p>The <code>Console</code> type itself is defined like this:</p>
<pre><code class="language-par">type Console = iterative choice {
  .close =&gt; !,
  .print(String) =&gt; self,
}
</code></pre>
<p>You can think of it as a “sink” object that receives strings and sends them to the terminal.
Much like <code>String.Builder</code>, but the output appears directly in your console.</p>
<p>Let’s tie it all together!</p>
<pre><code class="language-par">def Program: ! = do {
  let console = Console.Open
  let fib = Fibonacci

  Nat.Repeat(30).begin.case {
    .end! =&gt; {}
    .step remaining =&gt; {
      fib.next[n]
      console.print(Int.ToString(n))
      remaining.loop
    }
  }

  fib.close
  console.close
} in !
</code></pre>
<p>Here’s what’s happening:</p>
<ul>
<li><code>Nat.Repeat(30)</code> becomes the subject of the <code>.begin</code> and <code>.case</code> commands.</li>
<li>In each <code>.step</code>, we receive a number from the <code>fib</code> sequence using the <code>fib.next[n]</code> command.</li>
<li>We convert it to a string using <code>Int.ToString(n)</code> and print it to the console.</li>
<li>Then we <code>loop</code>.</li>
</ul>
<p>The <code>fib.next[n]</code> line is where <em>receive</em> command truly shines. It receives the payload
of the <code>.next</code> branch — a number — and updates <code>fib</code> to the rest of the sequence. Note, that
it’s a combination of two commands: a <em>selection</em> and a <em>receive</em>.</p>
<p>Once done, we close both the sequence and the console. We must, they are linear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels--linking"><a class="header" href="#channels--linking">Channels &amp; Linking</a></h1>
<p>In the previous sections, we built up values using the <code>do</code>/<code>in</code> expressions:</p>
<pre><code class="language-par">def Message = do {
  let builder = String.Builder
  builder.add("Hello")
  builder.add(", ")
  builder.add("World")
} in builder.build
</code></pre>
<p>This form lets you run a process — a sequence of commands — and then return a final expression
at the end.</p>
<p>But what if you want to <strong>return early,</strong> based on some logic? Par has no <em>return</em> keyword.
But it does have a deeper mechanism that allows exactly this — and more.</p>
<p>The <code>do</code>/<code>in</code> syntax is just <strong>sugar</strong> for something more fundamental: the <code>chan</code> expression,
combined with a command called linking. This:</p>
<pre><code class="language-par">do {
  &lt;process&gt;
} in &lt;value&gt;
</code></pre>
<p>is exactly the same as:</p>
<pre><code class="language-par">chan result {
  &lt;process&gt;
  result &lt;&gt; &lt;value&gt;
}
</code></pre>
<p>Let’s unpack what this means.</p>
<h2 id="the-chan-expression"><a class="header" href="#the-chan-expression">The <code>chan</code> Expression</a></h2>
<pre><code class="language-par">chan inner {
  // commands here
}
</code></pre>
<p>This expression creates a new channel, and spawns a process that runs the commands inside the
curly braces. That process is given access to one endpoint of the new channel —
named here as <code>inner</code>.</p>
<p>The <code>chan</code> expression itself evaluates to the other endpoint of the channel — that’s the value
the expression returns.</p>
<p><strong>The key is this:</strong> If the whole chan expression has type <code>T</code>, then inside the block, <code>inner</code>
has type <code>dual T</code>.</p>
<p>We’ll explore the details of dual types in the next section, but for now, here’s the intuition:
<strong>A type and its dual are two opposite side of communication.</strong> If one side offers something,
the other one requires it, and vice versa.</p>
<p>For example, if the whole <code>chan</code> expression should evaluate to an <code>Int</code>, then <code>dual Int</code> is
a <em>requirement</em> of an integer.</p>
<h2 id="linking--the--command"><a class="header" href="#linking--the--command">Linking — the <code>&lt;&gt;</code> command</a></h2>
<p>The link command is the simplest way to fulfill that requirement. If <code>x</code> has type <code>T</code>
and <code>y</code> has type <code>dual T</code>, then:</p>
<pre><code class="language-par">x &lt;&gt; y
</code></pre>
<p><strong>Connects the two endpoints,</strong> and ends the process.</p>
<p>For example:</p>
<pre><code class="language-par">def FortyTwo: Int = chan out {
  out &lt;&gt; 42
}
</code></pre>
<p>This returns the number <code>42</code>, using a full process.</p>
<p>Like all commands, <code>&lt;&gt;</code> operates on values — here, two channels — not processes.
You’re not linking a process to a value. You’re linking one channel to another.</p>
<blockquote>
<p><strong>Processes in <code>chan</code> must end.</strong> Every process inside a <code>chan</code> must end with one of two
commands:</p>
<ul>
<li>A <strong>link command</strong> (x &lt;&gt; y), or</li>
<li>A <strong>break command</strong> (x!), which we’ll meet in the next section.</li>
</ul>
<p>These are the only ways a process can terminate. If you reach the end of a <code>chan</code> block
without either one, it’s an error. This may seem a strange condition, but it’s important for
some concurrency invariants Par provides.</p>
<p>In contrast, <code>do</code>/<code>in</code> blocks don’t end themselves — they continue into the expression after <code>in</code>.</p>
</blockquote>
<p>Let’s write a function that can use that <strong>early return</strong>.</p>
<p>It takes a natural number (<code>Nat</code>) and returns a <code>String</code>.</p>
<ul>
<li>If the number is zero, it returns the string <code>"&lt;nothing&gt;"</code>.</li>
<li>Otherwise, it returns a string of exactly <code>n</code> hash marks (<code>"#"</code>).</li>
</ul>
<p>Here’s how that looks:</p>
<pre><code class="language-par">dec HashesOrNothing : [Nat] String
def HashesOrNothing = [n] chan result {
  Nat.Equals(n, 0).case {
    .true! =&gt; {
      result &lt;&gt; "&lt;nothing&gt;"
    }
    .false! =&gt; {}
  }

  let builder = String.Builder
  Nat.Repeat(n).begin.case {
    .end! =&gt; {}
    .step remaining =&gt; {
      builder.add("#")
      remaining.loop
    }
  }

  result &lt;&gt; builder.build
}
</code></pre>
<p>Let’s break this down:</p>
<ul>
<li><code>Nat.Equals(n, 0)</code> returns a <code>Bool</code>, which is an <a href="processes/../types/either.html"><code>either</code></a> with branches
<code>.true!</code> and <code>.false!</code>.</li>
<li>In the <code>.true!</code> branch, we immediately perform a link — returning <code>"&lt;nothing&gt;"</code>. Note, that
this <em>ends</em> the process.</li>
<li>The <code>.false!</code> branch does nothing on its own — the real work happens after the <code>.case</code>.</li>
<li>We build the result using a <code>String.Builder</code>, looping exactly <code>n</code> times using <code>Nat.Repeat</code>.</li>
<li>Finally, we link the builder’s result to <code>result</code>, ending the process.</li>
</ul>
<p>In the next section, we’ll learn how to exploit duality, to not just return, but sequentially
build on the opposing channels!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="construction-by-destruction"><a class="header" href="#construction-by-destruction">Construction by Destruction</a></h1>
<p>We’ve now seen the <code>chan</code> expression in action, using the obtained channel to return early
in its process. But that only scratches the surface!</p>
<p>The channel you obtain isn’t just a return handle — it’s a <strong>direct connection to the consumer</strong> of the result.
It can be interacted with sequentially, constructing a value step-by-step.</p>
<p>The title of this section, <em>“construction by destruction”,</em> is very apt! What we’re about to
learn here is exactly analogous to the famous trick in mathematics: <em>a proof by contradiction.</em>
And, it’s just as powerful.</p>
<h2 id="duality-in-theory"><a class="header" href="#duality-in-theory">Duality in theory</a></h2>
<p>Every type in Par has a <strong>dual</strong> — the opposite role in communication.</p>
<p>There is a type operator, <code>dual &lt;type&gt;</code>, which transforms a type to its dual. Here’s how
it’s defined structurally:</p>
<table>
<tr/>
<tr>
<td><code class="language-par">dual !
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">&#63;
</code></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual &#63;
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">!
</code></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual (A) B
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">[A] dual B
</code></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual [A] B
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">(A) dual B
</code></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">dual either {
  .left A,
  .right B,
}
</code></pre></td>
<td><strong>＝</strong></td>
<td><pre><code class="language-par">choice {
  .left => dual A,
  .right => dual B,
}
</code></pre></td>
</tr>
<tr/>
<tr>
<td><pre><code class="language-par">dual choice {
  .left => A,
  .right => B,
}
</code></pre></td>
<td><strong>＝</strong></td>
<td><pre><code class="language-par">either {
  .left dual A,
  .right dual B,
}
</code></pre></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual recursive F&lt;self&gt;
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">iterative dual F&lt;dual self&gt;
</code></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual iterative F&lt;self&gt;
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">recursive dual F&lt;dual self&gt;
</code></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual [type a] F&lt;a&gt;
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">(type a) dual F&lt;a&gt;
</code></td>
</tr>
<tr/>
<tr>
<td><code class="language-par">dual (type a) F&lt;a&gt;
</code></td>
<td><strong>＝</strong></td>
<td><code class="language-par">[type a] dual F&lt;a&gt;
</code></td>
</tr>
</table>
<blockquote>
<p>Don’t worry if the <code>F&lt;...&gt;</code> in recursive and generic types looks intimidating. It’s just a way to
formalize that after flipping from <code>recursive</code> to <code>iterative</code> (and similarly in the other cases),
we continue dualizing the body.”.</p>
</blockquote>
<p>Looking at the table, here’s what we can see:</p>
<ul>
<li><a href="processes/../types/unit.html">Units</a> are dual to <a href="processes/../types/continuation.html">continuations</a>.</li>
<li><a href="processes/../types/function.html">Functions</a> are dual to <a href="processes/../types/pair.html">pairs</a>.</li>
<li><a href="processes/../types/either.html">Eithers</a> are dual to <a href="processes/../types/choice.html">choices</a>.</li>
<li><a href="processes/../types/recursive.html">Recursives</a> are dual to <a href="processes/../types/iterative.html">iteratives</a>.</li>
<li><a href="processes/../types/forall.html">Foralls</a> are dual to <a href="processes/../types/exists.html">existentials</a>.</li>
<li><strong>The duality always goes both ways!</strong></li>
</ul>
<p>The last point is important. It’s a fact, in general, that <code>dual dual A</code> is equal to <code>A</code>.</p>
<h2 id="duality-in-action"><a class="header" href="#duality-in-action">Duality in action</a></h2>
<p>Here’s a familiar definition:</p>
<pre><code class="language-par">type List&lt;a&gt; = recursive either {
  .end!,
  .item(a) self,
}
</code></pre>
<p>So, what’s its dual? Applying the above rules, we get:</p>
<pre><code class="language-par">iterative choice {
  .end =&gt; ?,
  .item(a) =&gt; self,
}
</code></pre>
<p>While a <code>List&lt;a&gt;</code> provides items, until it reaches the end, its dual requires <em>you</em> to
give items (via the <code>.item</code> branch), or signal the end. Whoever is consuming a list,
this dual type provides a good way to communicate with them.</p>
<p>Notice the <code>?</code> in the <code>.end</code> branch. That’s a <strong>continuation.</strong> There is no expression syntax for
this type, but finally, we’re going to learn how to handle it in processes!</p>
<p>Remember: in a <code>chan</code>, the channel you obtain inside the block always has the <strong>dual type</strong> of the expression’s
final result. Let’s use this to construct a list step-by-step.</p>
<pre><code class="language-par">def SmallList: List&lt;Int&gt; = chan yield {
  yield.item(1)
  yield.item(2)
  yield.item(3)
  yield.end
  yield!
}

// def SmallList = *(1, 2, 3)
</code></pre>
<p>This is just a usual handling of an <a href="processes/../types/iterative.html">iterative</a>
<a href="processes/../types/choice.html">choice</a>, except for the last line.</p>
<p>Selecting the <code>.end</code> branch transforms the <code>yield</code> channel into a <code>?</code> — the continuation type. At that point,
the protocol is over, and only one command is valid: <strong>a break.</strong> It’s spelled <code>!</code>, that’s the last line:</p>
<pre><code class="language-par">  yield!  // break here
</code></pre>
<p>Like <a href="processes/./chan_expression.html#linking--the--command">linking</a>, it has to be the last command in
a process. In fact, <strong>link and break are the only ways to end a process.</strong></p>
<h2 id="a-real-example-flattening-a-list-of-lists"><a class="header" href="#a-real-example-flattening-a-list-of-lists">A real example: flattening a list of lists</a></h2>
<p>Let’s now use this style to implement something meaningful. We’ll write a function that flattens
a nested list:</p>
<pre><code class="language-par">dec Flatten : [type a] [List&lt;List&lt;a&gt;&gt;] List&lt;a&gt;
</code></pre>
<p>It’s a generic function, using the <a href="processes/../types/forall.html">forall</a> for polymorphism.</p>
<p>Here’s the full implementation, imperative-style:</p>
<pre><code class="language-par">def Flatten = [type a] [lists] chan yield {
  lists.begin/outer.case {
    .end! =&gt; {
      yield.end!
    }

    .item(list) =&gt; {
      list.begin/inner.case {
        .end! =&gt; {}
        .item(value) =&gt; {
          yield.item(value)
          list.loop/inner
        }
      }
      lists.loop/outer
    }
  }
}
</code></pre>
<p>It makes a bunch of concepts we’ve already covered come together.</p>
<ul>
<li>We loop through the outer list of lists using <code>.begin/outer</code> and <code>.loop/outer</code>.</li>
<li>If it’s <code>.end!</code>, we finish: <code>yield.end!</code>.</li>
<li>If it’s <code>.item(list)</code>, we then begin looping through the inner list.
<ul>
<li>We don’t manually bind the remainder of the list — the communication simply continues on
the original variable: <code>lists</code>.</li>
<li>The nested <code>.begin</code>/<code>.loop</code> shines here; no helper functions needed.</li>
</ul>
</li>
<li>In the inner loop:
<ul>
<li>If it’s <code>.end!</code>, we’re done with that list — we continue the outer loop.</li>
<li>If it’s <code>.item(value)</code>, we yield it to the consumer with <code>yield.item(value)</code>, then loop again.
Re-binding of the rest of the list is not needed here, either.</li>
</ul>
</li>
</ul>
<p>Duality combined with the <code>chan</code> expressions gives us a lot of expressivity.<br />
Constructing lists generator-style is just one of the use-cases.<br />
Whenever it feels more appropriate to <em>become a value</em> instead of constructing it from parts, <code>chan</code> and
duality come to the task!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Programs that interact with the real world must handle errors gracefully. Files don’t exist, networks disconnect, users type unexpected input. Most errors occur at I/O boundaries where your program meets external systems beyond its control.</p>
<p>Par takes a structured approach to error handling that builds on its linear type system. At its core, Par uses explicit Result types — but adds lightweight syntax sugar that makes working with errors feel natural while keeping the underlying semantics transparent.</p>
<h2 id="why-par-needs-unique-error-handling"><a class="header" href="#why-par-needs-unique-error-handling">Why Par Needs Unique Error Handling</a></h2>
<p>Par’s linear type system together with its concurrent evaluation creates a unique situation for error handling. Traditional approaches don’t work for Par:</p>
<p><strong>Exceptions</strong> propagate across call stacks, unwinding through multiple function calls automatically. But Par’s concurrent execution model has no call stacks! Instead, it has processes that communicate via channels. Any error must be explicitly passed via a channel, making something like a <code>Result</code> type necessary for error handling.</p>
<p><strong>Rust’s <code>?</code> operator</strong> works by dropping remaining owned values when propagating errors. This implicit cleanup doesn’t translate to Par’s linear types, where each value must be consumed according to its specific type and context.</p>
<p>Par needs error handling that makes cleanup fully explicit while remaining convenient to use. The <code>try</code>/<code>catch</code>/<code>throw</code> syntax sugar introduced here achieves this balance — borrowing familiar keywords from exception handling while operating very differently. Unlike traditional exceptions, Par’s error handling is purely local syntax sugar over <code>Result</code> types, with no hidden control flow or stack unwinding.</p>
<h2 id="working-with-files-error-handling-without-sugar"><a class="header" href="#working-with-files-error-handling-without-sugar">Working with Files: Error Handling Without Sugar</a></h2>
<p>Let’s start with a concrete example using Par’s file system operations through the <a href="./builtin.html"><code>Os</code> module</a>. The <code>Os.Path</code> type provides methods for working with the filesystem — creating files, reading directories, and so on. Most of these operations can fail, so they return <code>Result</code> values.</p>
<p>Here’s what error handling looks like without any syntax sugar. We’ll write a program that creates a log file and writes some entries to it:</p>
<pre><code class="language-par">def Main: ! = chan exit {
  let console = Console.Open

  let path = Os.PathFromString("logs.txt")
  path.createOrAppendToFile.case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok writer =&gt; {}
  }
  // ...
</code></pre>
<p>A few things to note about this pattern:</p>
<p>The <code>chan exit</code> creates a channel called <code>exit</code> of type <code>?</code> — <a href="./processes/duality.html">the continuation type</a>, which is dual to our <code>Main</code> function’s return type <code>!</code>. The <code>exit!</code> syntax is the <em>break</em> command applied to this continuation, which ends the process.</p>
<p>After the <code>.case</code> block, the <code>writer</code> variable is available in the surrounding scope. This is how process-scoped variables work in Par — variables bound in <code>.case</code> branches continue to exist after the case analysis.</p>
<pre><code class="language-par">  writer.writeString("[INFO] First new log\n").case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok =&gt; {}
  }
</code></pre>
<p>In <a href="./process_syntax.html">process syntax</a>, when we use <code>.ok =&gt;</code>, the subject of the command (<code>writer</code>) gets updated to the payload of the .ok branch. Since <code>.writeString</code> returns the same <code>Os.Writer</code> type on success, <code>writer</code> remains usable.</p>
<pre><code class="language-par">  writer.writeString("[INFO] Second new log\n").case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok =&gt; {}
  }
</code></pre>
<p>And finish by closing the file:</p>
<pre><code class="language-par">  writer.close(.ok!).case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok! =&gt; {}
  }
  exit!
}
</code></pre>
<p>Note the <code>.ok!</code> pattern here — after closing, the writer becomes a unit value <code>!</code>.</p>
<p>Here’s the complete program:</p>
<pre><code class="language-par">def Main: ! = chan exit {
  let console = Console.Open

  let path = Os.PathFromString("logs.txt")
  path.createOrAppendToFile.case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok writer =&gt; {}
  }
  
  writer.writeString("[INFO] First new log\n").case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok =&gt; {}
  }
  writer.writeString("[INFO] Second new log\n").case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok =&gt; {}
  }

  writer.close(.ok!).case {
    .err e =&gt; {
      console.print(e)
      console.close
      exit!
    }
    .ok! =&gt; {}
  }

  console.close
  exit!
}
</code></pre>
<p>This is extremely verbose! The same error handling code is repeated for every operation that might fail. Let’s see how Par’s error handling sugar can clean this up.</p>
<h2 id="the-same-program-with-trycatch"><a class="header" href="#the-same-program-with-trycatch">The Same Program with <code>try</code>/<code>catch</code></a></h2>
<p>Here’s the exact same functionality using Par’s error handling syntax:</p>
<pre><code class="language-par">def Main: ! = chan exit {
  let console = Console.Open

  catch e =&gt; {
    console.print(e)
    console.close
    exit!
  }

  let path = Os.PathFromString("logs.txt")
  let try writer = path.createOrAppendToFile
  
  writer.writeString("[INFO] First new log\n").try
  writer.writeString("[INFO] Second new log\n").try

  writer.close(.ok!).try
  console.close
  exit!
}
</code></pre>
<p>Significantly shorter and more readable! The error handling is declared once and applies to all subsequent operations.</p>
<h2 id="how-trycatchthrow-work-in-process-syntax"><a class="header" href="#how-trycatchthrow-work-in-process-syntax">How <code>try</code>/<code>catch</code>/<code>throw</code> Work in Process Syntax</a></h2>
<p>Par’s error handling sugar is built around small, local keywords that desugar to explicit <code>Result</code> handling. Let’s understand how they work.</p>
<h3 id="the-catch-statement"><a class="header" href="#the-catch-statement">The <code>catch</code> Statement</a></h3>
<p>Before you can use <code>try</code> or <code>throw</code>, you must define a <code>catch</code> block in the same process. This restriction is crucial — the corresponding <code>try</code> and <code>throw</code> commands must be in the same sequential process as their <code>catch</code>, not in nested processes or expressions.</p>
<pre><code class="language-par">catch &lt;pattern&gt; =&gt; {
  &lt;process&gt;
}
</code></pre>
<p>The <code>&lt;pattern&gt;</code> can be any pattern like those used in <code>let</code> statements or function parameters. Usually this is a simple variable name, but you can use more complex patterns when needed.</p>
<p>For example, if the error type is unit:</p>
<pre><code class="language-par">catch ! =&gt; { ... }
</code></pre>
<p>You can also include type annotations:</p>
<pre><code class="language-par">catch e: Os.Error =&gt; { ... }
</code></pre>
<p>The <code>&lt;process&gt;</code> inside a <code>catch</code> block must end with a process-ending command:</p>
<ul>
<li><em>break:</em> <code>continuation!</code></li>
<li><em>linking:</em> <code>left &lt;&gt; right</code></li>
<li><code>.loop</code> to return to a .begin that’s outside the catch block, useful for retrying operations</li>
<li><code>throw</code> to jump to another <code>catch</code> block</li>
</ul>
<h3 id="the-throw-command"><a class="header" href="#the-throw-command">The <code>throw</code> Command</a></h3>
<p><code>throw</code> jumps directly to a <code>catch</code> block with an error value:</p>
<pre><code class="language-par">catch e =&gt; {
  console.print(e)
  console.close
  exit!
}

throw "Total meltdown"
</code></pre>
<p>This is equivalent to executing the catch block directly:</p>
<pre><code class="language-par">console.print("Total meltdown")
console.close
exit!
</code></pre>
<p><code>throw</code> is useful for creating custom error conditions in your logic.</p>
<h2 id="the-try-patterns-and-commands"><a class="header" href="#the-try-patterns-and-commands">The <code>try</code> Patterns and Commands</a></h2>
<p>The real power comes from <code>try</code>, which provides conditional error handling based on <code>Result</code> values:</p>
<pre><code class="language-par">type Result&lt;e, a&gt; = either {
  .err e,
  .ok a,
}
</code></pre>
<p><code>try</code> appears in two contexts: <em>patterns</em> and <em>commands.</em></p>
<h3 id="try-in-commands"><a class="header" href="#try-in-commands"><code>.try</code> in Commands</a></h3>
<p>The <code>.try</code> postfix transforms verbose <code>Result</code> case analysis into clean linear code. Remember our original verbose version:</p>
<pre><code class="language-par">writer.writeString("[INFO] First new log\n").case {
  .err e =&gt; {
    console.print(e)
    console.close
    exit!
  }
  .ok =&gt; {}
}
</code></pre>
<p>With <code>.try</code>, this becomes:</p>
<pre><code class="language-par">writer.writeString("[INFO] First new log\n").try
</code></pre>
<p>The <code>.try</code> postfix desugars any command or expression returning a <code>Result</code>:</p>
<pre><code class="language-par">variable.try
</code></pre>
<p>becomes:</p>
<pre><code class="language-par">variable.case {
  .err e =&gt; {
    throw e
  }
  .ok =&gt; {}
}
</code></pre>
<p>This works for more complex command chains too. Consider this type for polling data with possible errors:</p>
<pre><code class="language-par">type Poll&lt;e, a&gt; = iterative choice {
  .close =&gt; Result&lt;e, !&gt;,
  .poll =&gt; Result&lt;e, (a) self&gt;,
}
</code></pre>
<p>You can poll an element and handle errors seamlessly:</p>
<pre><code class="language-par">// source : Poll&lt;Os.Error, String&gt;
source.poll.try[value]
</code></pre>
<p>After this command, <code>source</code> maintains its <code>Poll&lt;Os.Error, String&gt;</code> type and value contains the successfully polled <code>String</code>.</p>
<!-- moved `default` to the end of this chapter -->
<h3 id="the-concurrent-evaluation-restriction"><a class="header" href="#the-concurrent-evaluation-restriction">The Concurrent Evaluation Restriction</a></h3>
<p>You might think this would work:</p>
<pre><code class="language-par">let writer = path.createOrAppendToFile.try
</code></pre>
<p>However, this causes a type error. The reason reveals something fundamental about Par’s evaluation model.</p>
<p>Par evaluates expressions concurrently with the processes that use them. When you write:</p>
<pre><code class="language-par">let writer = path.createOrAppendToFile.try
</code></pre>
<p>The expression <code>path.createOrAppendToFile</code> runs concurrently with the process doing the <code>let</code>. If the expression were to fail on <code>.try</code>, the main process might already be executing other commands — there’s no sound way to “rewind” that execution.</p>
<p>This is why <code>try</code> and <code>throw</code> can only be used in the same process as their corresponding <code>catch</code>, not in nested expressions or processes.</p>
<h3 id="try-in-patterns"><a class="header" href="#try-in-patterns"><code>try</code> in Patterns</a></h3>
<p>The solution is to use <code>try</code> in the pattern itself:</p>
<pre><code class="language-par">let try writer = path.createOrAppendToFile
</code></pre>
<p>This moves the error handling into the correct process. The desugaring is:</p>
<pre><code class="language-par">let writer = path.createOrAppendToFile
writer.case {
  .err e =&gt; {
    throw e
  }
  .ok =&gt; {}
}
</code></pre>
<p>Since <code>try</code> is part of the pattern, it works in nested patterns too:</p>
<pre><code class="language-par">let (try leftReader, try rightReader)! = (
  leftPath.openFile,
  rightPath.openFile,
)!
</code></pre>
<p>And it works in receive commands, too. The <code>Console</code> type demonstrates this well:</p>
<pre><code class="language-par">type Console = iterative choice {
  .close =&gt; !,
  .print(String) =&gt; self,
  .prompt(String) =&gt; (Result&lt;!, String&gt;) self,
}
</code></pre>
<p>The <code>.prompt</code> method returns a <code>Result</code> while keeping the console alive for more operations:</p>
<pre><code class="language-par">let console = Console.Open

catch ! =&gt; {
  console.print("Failed to read input.")
  console.close
  exit!
}

console.prompt("What's your name?")[try name]
console.prompt("What's your address?")[try address]
</code></pre>
<h2 id="error-handling-in-expression-syntax"><a class="header" href="#error-handling-in-expression-syntax">Error Handling in Expression Syntax</a></h2>
<p>Par also supports <code>try</code>/<code>catch</code> directly in expressions, with syntax adapted for expression contexts:</p>
<pre><code class="language-par">catch &lt;pattern&gt; =&gt; &lt;err result&gt; in &lt;expression using try/throw&gt;
</code></pre>
<p>The same concurrent evaluation restrictions apply, with an additional constraint: <code>try</code>/<code>throw</code> can only be used before any part of the result is constructed.</p>
<p>This is invalid because <code>result.try</code> appears in a nested expression, which runs as a separate concurrent process:</p>
<pre><code class="language-par">// result : Result&lt;String, Int&gt;
catch e =&gt; .err e in
.ok Int.Add(result.try, 1)
</code></pre>
<p>This fix attempts to work around the nested expression issue but still fails — the outer <code>.ok</code> constructs part of the result before <code>try</code> executes:</p>
<pre><code class="language-par">catch e =&gt; .err e in
.ok let try value = result in
Int.Add(value, 1)
</code></pre>
<p>Here’s the correct version:</p>
<pre><code class="language-par">catch e =&gt; .err e in
let try value = result in
.ok Int.Add(value, 1)
</code></pre>
<p>This ensures all error handling completes before constructing the result.</p>
<h3 id="useful-expression-patterns"><a class="header" href="#useful-expression-patterns">Useful Expression Patterns</a></h3>
<p>Expression-form <code>catch</code> enables several common patterns:</p>
<h4 id="mapping-the-error-adding-context"><a class="header" href="#mapping-the-error-adding-context">Mapping the error (adding context):</a></h4>
<pre><code class="language-par">catch e =&gt; .err String.Builder.add("Failed to process file: ").add(e).build in
let try content = file.readAll in 
.ok ProcessContent(content)
</code></pre>
<h4 id="mapping-the-success-value"><a class="header" href="#mapping-the-success-value">Mapping the success value:</a></h4>
<pre><code class="language-par">catch e =&gt; .err e in
let try rawData = source.fetch in 
.ok Encode(rawData)
</code></pre>
<h4 id="unwrapping-with-a-default-value"><a class="header" href="#unwrapping-with-a-default-value">Unwrapping with a default value:</a></h4>
<pre><code class="language-par">catch ! =&gt; "Unknown" in 
config.getUserName.try
</code></pre>
<h2 id="labels-and-layered-error-handling"><a class="header" href="#labels-and-layered-error-handling">Labels and Layered Error Handling</a></h2>
<p>Like <code>begin</code>/<code>loop</code>, <code>catch</code> blocks can be labeled for precise control:</p>
<pre><code class="language-par">catch/label e =&gt; { ... }
</code></pre>
<p>The corresponding <code>try</code> and <code>throw</code> commands reference the same label:</p>
<pre><code class="language-par">let try/label value = result
throw/label "Custom error"
</code></pre>
<p>Labels are selected by proximity and name, not by error type. The nearest <code>catch</code> with the matching label (or no label) is chosen. This allows different error types to be routed to different handlers:</p>
<pre><code class="language-par">catch/fs e =&gt; { /* handle file system errors */ }
catch/net e =&gt; { /* handle network errors */ }

let try/fs writer = path.createFile
let try/net conn = url.connect
</code></pre>
<h3 id="throwing-to-previous-catch-blocks"><a class="header" href="#throwing-to-previous-catch-blocks">Throwing to Previous <code>catch</code> Blocks</a></h3>
<p>A powerful pattern is using nested <code>catch</code> blocks for resource cleanup while delegating to outer blocks for shared error handling.</p>
<p>Here’s a simple example showing the basic pattern:</p>
<pre><code class="language-par">catch e =&gt; {
  Debug.Log("Main error handler")
  Debug.Log(e)
  exit!
}

let try resource = AcquireResource
catch e =&gt; {
  resource.cleanup
  throw e  // delegate to the main handler above
}

// use resource, but error might occur elsewhere
let try otherData = SomeOtherOperation  // this might fail
ProcessTogether(resource, otherData)
</code></pre>
<p>The inner <code>catch</code> handles cleanup of the specific resource, then <code>throw</code>s to the outer <code>catch</code> for shared error reporting logic. The key point is that the error occurs in <code>SomeOtherOperation</code>, not in the resource itself, so the resource is still valid and needs proper cleanup.</p>
<p>Here’s this pattern in a more complex, real-world example — copying a file with proper resource management:</p>
<pre><code class="language-par">def Main: ! = chan exit {
  let console = Console.Open

  catch ! =&gt; { console.print("Failed to read input.").close; exit! }
  console.prompt("Src path: ")[try src]
  console.prompt("Dst path: ")[try dst]

  catch e: Os.Error =&gt; {
    console.print("An error occurred:")
    console.print(e)
    console.close
    exit!
  }

  let try reader = Os.PathFromString(src).openFile
  catch/w e =&gt; { reader.close(.ok!); throw e }

  let try/w writer = Os.PathFromString(dst).createOrReplaceFile
  catch/r e =&gt; { writer.close(.ok!); throw e }

  reader.begin.read.try/r.case {
    .end! =&gt; {
      writer.close(.ok!).try
      console.close
      exit!
    }
    .chunk(bytes) =&gt; {
      writer.write(bytes).try/w
      reader.loop
    }
  }
}
</code></pre>
<p>Here, the <code>catch/r</code> and <code>catch/w</code> blocks provide resource-specific cleanup (closing file handles) but then throw to the main error handler for shared logic like printing the error and exiting.</p>
<p>This layered approach allows you to build sophisticated error handling hierarchies while keeping each level focused and clear.</p>
<h2 id="propagating-errors-in-functions"><a class="header" href="#propagating-errors-in-functions">Propagating Errors in Functions</a></h2>
<p>The examples so far have shown terminal error handling — printing errors and exiting. But often you want to propagate errors up to the caller. Here’s a utility function that reads an entire file’s contents:</p>
<pre><code class="language-par">dec ReadAll : [Os.Path] Result&lt;Os.Error, Bytes&gt;
def ReadAll = [path] chan return {
  catch e =&gt; { return &lt;&gt; .err e }
  let try reader = path.openFile
  let parser = Bytes.ParseReader(type either{}, Os.Error)(reader)
  let try contents = parser.remainder
  return &lt;&gt; .ok contents
}
</code></pre>
<p>This function uses <code>Bytes.ParseReader</code> to convert the chunked <code>Bytes.Reader</code> from <code>path.openFile</code> into a parser that provides a convenient <code>.remainder</code> method for reading all contents at once. The <code>catch</code> block propagates any errors by linking them into an <code>.err</code> result, while success links the contents into an <code>.ok</code> result.</p>
<h2 id="providing-defaults-with-default"><a class="header" href="#providing-defaults-with-default">Providing defaults with <code>default</code></a></h2>
<p>Sometimes you don’t want to propagate an error — you want to replace it with a fallback and keep going. The <code>default</code> sugar does exactly that, and unlike <code>try</code>, it is completely standalone: it does not require a surrounding <code>catch</code>, and it is valid even in nested expression positions.</p>
<ul>
<li>
<p>Postfix form (expressions/commands):</p>
<pre><code class="language-par">let r1: Result&lt;!, Int&gt; = .ok 7
let r2: Result&lt;!, Int&gt; = .err!

let x = r1.default(0)   // x = 7
let y = r2.default(0)   // y = 0
</code></pre>
<p>This desugars to a <code>.case</code> on the subject: on <code>.ok</code> it continues with the unwrapped value, on <code>.err</code> it evaluates the fallback expression and uses that value instead. Because it is a local rewrite, it can be used directly in <code>let</code> bindings and other expression contexts.</p>
</li>
<li>
<p>Pattern form (including in receives):</p>
<pre><code class="language-par">let default(0) n = Nat.FromString("oops")
</code></pre>
<p>The pattern binds on <code>.ok</code>, and binds the fallback expression on <code>.err</code>.</p>
<p>Here’s a practical example that shows why the pattern form is particularly useful with receive commands. It counts word occurrences using a map; when a key is missing, it starts from <code>0</code>:</p>
<pre><code class="language-par">dec Counts : [List&lt;String&gt;] List&lt;(String) Nat&gt;
def Counts = [words] do {
  let counts = Map.String(type Nat)(*())
  words.begin.case {
    .end! =&gt; {}
    .item(word) =&gt; {
      counts.entry(word)[default(0) count]
      counts.put(Nat.Add(count, 1))
      words.loop
    }
  }
} in counts.list
</code></pre>
<p>In the <code>.item</code> branch, <code>counts.entry(word)</code> returns a <code>Result&lt;!, Nat&gt;</code> via a receive; <code>default(0)</code> seamlessly handles the missing case and binds <code>count</code> to <code>0</code>.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
