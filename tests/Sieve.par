type CoList<a> = iterative choice {
	.end => !,
	.item => (a) self,
}

dec FinFilter : [type a] [CoList<box a>, box [box a] Bool, Nat] CoList<box a>
def FinFilter =
	[type a]
	[xs, f, n]
	begin case {
		.end => xs.end,
		.item =>
			do { xs.item[x] } in
			Nat.RepeatLazy(n).begin@search.case {
				.end! => (x) loop,
				.step i => f(x).case {
					.false! =>
						do { xs.item[x] } in
						i.next.loop@search,
					.true! => (x) loop,
				},
			},
	}

dec Take : [type a] [CoList<a>, Nat] List<a>
def Take =
	[type a]
	[xs, n]
	Nat.RepeatLazy(n).begin.case {
		.end! => .end xs.end,
		.step i =>
			do { xs.item[x] } in
			.item(x)
			i.next.loop,
	}

dec NatNotDivides : [Nat, Nat] Bool
def NatNotDivides =
	[x, y]
	Nat.Equals(Nat.Mod(x, y), 0).case {
		.true! => .false!,
		.false! => .true!,
	}

dec ListEquals : [type a] [List<box a>, List<box a>, box [box a, box a] Bool] Bool
def ListEquals =
	[type a]
	[xs, ys, f]
	xs.begin.case {
		.end! => ys.case {
			.end! => .true!,
			.item _ => .false!,
		},
		.item(x) xs => ys.case {
			.end! => .false!,
			.item(y) ys => f(x, y).case {
				.true! => xs.loop,
				.false! => .false!,
			},
		},
	}

dec Sieve : CoList<Nat>
def Sieve =
	let list : CoList<Nat> =
		let n = 2 in
		begin case {
			.end => !,
			.item =>
				(n)
				let n = Nat.Add(n, 1) in
				loop,
		}
	in
	let stride = 1 in
	begin case {
		.end => list.end,
		.item =>
			do {
				list.item[x]
				let stride = Nat.Mul(stride, x)
				let list = FinFilter(type Nat)(
					list,
					box [y] NatNotDivides(y, x),
					stride
				)
			} in
			(x) loop,
	}

def TestSieve : [Test] ! =
	[test]
	do {
		let primes : List<Nat> = *(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)
		test.assert(
			"Sieve finds primes",
			ListEquals(type Nat)(
				Take(type Nat)(Sieve, 25),
				primes,
				box Nat.Equals
			)
		)
	} in !


def TestCalcSieve: [Test] ! = [test] do {
	let console = Console.Open
	let sieve = Sieve
	let sum = 0
	Nat.RepeatLazy(100).begin.case {
		.end! => {}
		.step i => {
			sieve.item[prime]
			sum->Nat.Add(prime)
			i.next.loop
		}
	}
	sieve.end
	console.close
} in !
