dec StartGame : [Player, Player] Game

type Move = either {
  .rock!,
  .paper!,
  .scissors!,
}

type Player = iterative@game choice {
  .stop => !,
  .playRound => iterative@round choice {
    .stopRound => self@game,
    .playMove => (Move) choice {
      .win  => self@game,
      .lose => self@game,
      .draw => self@round,
    },
  },
}

type Outcome = either {
  .firstWon!,
  .secondWon!,
  .tooLong!,
}

type Game = iterative choice {
  .stop => !,
  .playRound => (Outcome) self,
}

def StartGame = [p1, p2] begin@game case {
  .stop => do {
    p1.stop?
    p2.stop?
  } in !,

  .playRound => do {
    let limit = 3
    p1.playRound
    p2.playRound
  } in Nat.Repeat(limit).begin.case {
    .end! => do {
      p1.stopRound
      p2.stopRound
    } in (.tooLong!) loop@game,

    .step remaining => do {
      p1.playMove[move1]
      p2.playMove[move2]
    } in CalculateRound(move1, move2).case {
      .first! => do {
        p1.win
        p2.lose
      } in (.firstWon!) loop@game,

      .second! => do {
        p1.lose
        p2.win
      } in (.secondWon!) loop@game,

      .draw! => do {
        p1.draw
        p2.draw
      } in remaining.loop,
    }
  },
}

dec CalculateRound : [Move, Move] either { .first!, .second!, .draw! }
def CalculateRound = [move1, move2] move1.case {
  .rock! => move2.case {
    .rock! => .draw!
    .paper! => .second!
    .scissors! => .first!
  }
  .paper! => move2.case {
    .rock! => .first!
    .paper! => .draw!
    .scissors! => .second!
  }
  .scissors! => move2.case {
    .rock! => .second!
    .paper! => .first!
    .scissors! => .draw!
  }
}
